<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <title>Automatizador de Notas – Santomé</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

<!-- Bibliotecas locais (PDF.js, Tesseract.js, SheetJS) -->
<script type="module">
  /* ---------- PDF.js ---------- */
  import * as pdfjsLib from './libs/pdf.min.mjs';
  pdfjsLib.GlobalWorkerOptions.workerSrc = './libs/pdf.worker.min.mjs';
  window.pdfjsLib = pdfjsLib;

  /* ---------- Tesseract.js ---------- */
  import Tesseract from './libs/tesseract.esm.min.js';
  const { createWorker } = Tesseract;
  window.Tesseract = { ...Tesseract, createWorker };

  /* ---------- SheetJS ---------- */
  import * as XLSX from './libs/xlsx.mjs';
  window.XLSX = XLSX;

  // Executar verificação após carregamento
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(checkLibraries, 500);
  });
</script>

<!-- Font Awesome -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
/* ====== Variáveis de cor ====== */
:root {
  --primary-color: #304ffe;
  --secondary-color: #eef2ff;
  --border-color: #d9d9d9;
  --success-color: #00c853;
  --error-color: #d32f2f;
  --warning-color: #ff9800;
  --light-text: #666;
  --bg-color: #f8f9fa;
  --card-bg: #ffffff;
  --shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #1a1a1a;
    --card-bg: #2d2d2d;
    --border-color: #404040;
    --light-text: #ccc;
  }
}

/* Garantir que a tabela sempre tenha fundo claro */
.table-container {
  background-color: #ffffff !important;
}

table {
  background-color: #ffffff !important;
}

th, td {
  background-color: #ffffff !important;
  color: #333333 !important;
}

th {
  background-color: #f0f4ff !important;
}

/* Reset e base */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background-color: var(--bg-color);
  color: #333;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Header */
header {
  background: linear-gradient(135deg, var(--primary-color), #1e88e5);
  color: white;
  padding: 2rem 0;
  text-align: center;
  box-shadow: var(--shadow);
}

header h1 {
  font-size: 2.5rem;
  font-weight: 300;
  margin-bottom: 0.5rem;
}

header p {
  opacity: 0.9;
  font-size: 1.1rem;
}

/* Main container */
main {
  flex: 1;
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem 1rem;
  width: 100%;
}

/* Status section */
.status-section {
  background: var(--card-bg);
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow);
  text-align: center;
  display: none;
}

.status-ok {
  color: var(--success-color);
}

.status-error {
  color: var(--error-color);
}

/* Upload section */
.upload-section {
  background: var(--card-bg);
  border-radius: 12px;
  padding: 2rem;
  margin-bottom: 2rem;
  box-shadow: var(--shadow);
  border: 2px dashed var(--border-color);
  transition: all 0.3s ease;
}

.upload-section.dragover {
  border-color: var(--primary-color);
  background-color: var(--secondary-color);
  transform: scale(1.02);
}

.upload-area {
  text-align: center;
  padding: 3rem 2rem;
  cursor: pointer;
  border-radius: 8px;
  transition: background-color 0.3s ease;
}

.upload-area:hover {
  background-color: var(--secondary-color);
}

.upload-icon {
  font-size: 4rem;
  color: var(--primary-color);
  margin-bottom: 1rem;
}

.upload-text {
  font-size: 1.2rem;
  margin-bottom: 0.5rem;
  color: #333;
}

.upload-hint {
  color: var(--light-text);
  font-size: 0.9rem;
}

#fileInput {
  display: none;
}

/* Progress section */
.progress-section {
  margin-top: 1.5rem;
  display: none;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background-color: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 0.5rem;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--primary-color), var(--success-color));
  width: 0%;
  transition: width 0.3s ease;
}

.progress-text {
  font-size: 0.9rem;
  color: var(--light-text);
  text-align: center;
}

/* Results section */
.results-section {
  display: none;
  background: var(--card-bg);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: var(--shadow);
}

.results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
  gap: 1rem;
}

.results-title {
  font-size: 1.5rem;
  color: #333;
}

.export-btn {
  background: var(--success-color);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: all 0.3s ease;
}

.export-btn:hover:not(:disabled) {
  background: #4caf50;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
}

.export-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
  transform: none;
}

/* Table container */
.table-container {
  overflow-x: auto;
  margin-bottom: 20px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
  background: var(--card-bg);
}

th, td {
  padding: 0.75rem;
  text-align: left;
  border-bottom: 1px solid var(--border-color);
  vertical-align: top;
}

th {
  background: var(--secondary-color);
  font-weight: 600;
  color: #333;
  position: sticky;
  top: 0;
  z-index: 10;
}

td[contenteditable="true"] {
  border: 2px solid transparent;
  border-radius: 4px;
  transition: border-color 0.3s ease;
  cursor: text;
}

td[contenteditable="true"]:hover {
  border-color: var(--primary-color);
  background-color: var(--secondary-color);
}

td[contenteditable="true"]:focus {
  outline: none;
  border-color: var(--primary-color);
  background-color: white;
}

/* Confidence indicator */
.confidence-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-left: 5px;
  cursor: help;
}

.confidence-high {
  background-color: var(--success-color);
}

.confidence-medium {
  background-color: var(--warning-color);
}

.confidence-low {
  background-color: var(--error-color);
}

.error-row {
  background-color: #ffebee;
}

.error-row td {
  color: var(--error-color);
}

.delete-btn {
  background: var(--error-color);
  color: white;
  border: none;
  padding: 0.5rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.3s ease;
}

.delete-btn:hover {
  background: #c62828;
  transform: scale(1.1);
}

/* Processing info section */
.processing-info {
  background: #e3f2fd;
  border-left: 4px solid var(--primary-color);
  padding: 1rem;
  margin-bottom: 1rem;
  border-radius: 4px;
  display: none;
}

.processing-info h3 {
  color: var(--primary-color);
  margin-bottom: 0.5rem;
}

.processing-details {
  font-size: 0.9rem;
  color: #555;
}

/* Debug section */
.debug-section {
  margin-top: 2rem;
  background: #f5f5f5;
  border-radius: 8px;
  padding: 1rem;
  display: none;
}

.debug-section h3 {
  margin-bottom: 1rem;
  color: #666;
}

.debug-text {
  font-family: monospace;
  font-size: 0.8rem;
  background: white;
  padding: 1rem;
  border-radius: 4px;
  max-height: 300px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-all;
}

/* Footer */
footer {
  background: #333;
  color: white;
  text-align: center;
  padding: 1.5rem;
  margin-top: 2rem;
}

footer a {
  color: var(--primary-color);
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

/* Loading spinner */
.spinner {
  border: 3px solid #f3f3f3;
  border-top: 3px solid var(--primary-color);
  border-radius: 50%;
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
  display: inline-block;
  margin-right: 0.5rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Responsive design */
@media (max-width: 768px) {
  header h1 {
    font-size: 2rem;
  }
  
  main {
    padding: 1rem;
  }
  
  .upload-section,
  .results-section {
    padding: 1.5rem;
  }
  
  .upload-area {
    padding: 2rem 1rem;
  }
  
  .upload-icon {
    font-size: 3rem;
  }
  
  .results-header {
    flex-direction: column;
    align-items: stretch;
  }
  
  table {
    font-size: 0.8rem;
  }
  
  th, td {
    padding: 0.5rem;
  }
}

@media (max-width: 360px) {
  header {
    padding: 1.5rem 0;
  }
  
  header h1 {
    font-size: 1.8rem;
  }
  
  .upload-section,
  .results-section {
    padding: 1rem;
  }
  
  .upload-area {
    padding: 1.5rem 0.5rem;
  }
}
</style>
</head>

<body>
  <header>
    <h1><i class="fas fa-file-invoice"></i> Automatizador de Notas</h1>
    <p>Extração inteligente com validação cruzada para COMERCIO DE BANANAS SANTOMÉ LTDA</p>
  </header>

  <main>
    <!-- Status section -->
    <section class="status-section" id="statusSection">
      <div id="statusMessage">Carregando bibliotecas...</div>
    </section>

    <section class="upload-section" id="uploadSection">
      <div class="upload-area" onclick="document.getElementById('fileInput').click()">
        <div class="upload-icon">
          <i class="fas fa-cloud-upload-alt"></i>
        </div>
        <div class="upload-text">Solte aqui PDFs, XMLs ou imagens</div>
        <div class="upload-hint">ou clique para selecionar arquivos</div>
      </div>
      <input type="file" id="fileInput" multiple accept=".pdf,.xml,image/*">
      
      <div class="progress-section" id="progressSection">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">Processando arquivos...</div>
      </div>
    </section>

    <!-- Processing info -->
    <section class="processing-info" id="processingInfo">
      <h3><i class="fas fa-info-circle"></i> Validação Inteligente</h3>
      <div class="processing-details" id="processingDetails"></div>
    </section>

    <section class="results-section" id="resultsSection">
      <div class="results-header">
        <h2 class="results-title">Resultados Extraídos</h2>
        <button class="export-btn" id="exportBtn" disabled>
          <i class="fas fa-file-excel"></i>
          Exportar Excel
        </button>
      </div>
      
      <div class="table-container">
        <table id="resultsTable">
          <thead>
            <tr>
              <th>CNPJ Emitente</th>
              <th>Nome Emitente</th>
              <th>Data Emissão</th>
              <th>Nº Documento</th>
              <th>Valor Total</th>
              <th>Descrição</th>
              <th>Confiança</th>
              <th>Ações</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Debug section -->
    <section class="debug-section" id="debugSection">
      <h3>Debug - Dados Extraídos</h3>
      <div class="debug-text" id="debugText"></div>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 COMERCIO DE BANANAS SANTOMÉ LTDA | 
    <a href="#" onclick="toggleDebug()">Debug Mode</a></p>
  </footer>

  <script>
    // ===== VARIÁVEIS GLOBAIS =====
    let processedFiles = 0;
    let totalFiles = 0;
    let extractedData = [];
    let debugMode = false;
    let librariesLoaded = false;
    let tesseractWorker = null;
    
    // CNPJ da empresa (tomador) - ignorar
    const COMPANY_CNPJ = '07.925.317/0001-88';
    
    // ===== SISTEMA DE CACHE MELHORADO =====
    const DataCache = {
      emitentes: new Map(),
      
      setEmitente(cnpj, data) {
        const key = cnpj.replace(/\D/g, '');
        this.emitentes.set(key, data);
        localStorage.setItem('cache_emitente_' + key, JSON.stringify(data));
      },
      
      getEmitente(cnpj) {
        const key = cnpj.replace(/\D/g, '');
        if (this.emitentes.has(key)) {
          return this.emitentes.get(key);
        }
        
        const cached = localStorage.getItem('cache_emitente_' + key);
        if (cached) {
          const data = JSON.parse(cached);
          this.emitentes.set(key, data);
          return data;
        }
        
        return null;
      }
    };
    
    // ===== SISTEMA DE VALIDAÇÃO E CONFIANÇA =====
    class DataValidator {
      static calculateConfidence(extractedData, source) {
        let totalScore = 0;
        let fieldCount = 0;
        
        // Scores por campo
        const fieldScores = {};
        
        // CNPJ
        if (extractedData.cnpj_emitente) {
          const cnpjScore = this.validateCNPJ(extractedData.cnpj_emitente) ? 100 : 50;
          fieldScores.cnpj = cnpjScore;
          totalScore += cnpjScore;
          fieldCount++;
        }
        
        // Nome
        if (extractedData.nome_emitente) {
          const nameScore = extractedData.nome_emitente.length > 5 ? 100 : 50;
          fieldScores.nome = nameScore;
          totalScore += nameScore;
          fieldCount++;
        }
        
        // Data
        if (extractedData.data_emissao) {
          const dateScore = this.isValidDate(extractedData.data_emissao) ? 100 : 50;
          fieldScores.data = dateScore;
          totalScore += dateScore;
          fieldCount++;
        }
        
        // Valor
        if (extractedData.valor_total) {
          const valueScore = this.isValidMonetaryValue(extractedData.valor_total) ? 100 : 50;
          fieldScores.valor = valueScore;
          totalScore += valueScore;
          fieldCount++;
        }
        
        // Número do documento
        if (extractedData.numero_documento) {
          const docScore = extractedData.numero_documento.match(/^\d{3,10}$/) ? 100 : 70;
          fieldScores.documento = docScore;
          totalScore += docScore;
          fieldCount++;
        }
        
        // Bonus por fonte
        if (source === 'xml') {
          totalScore += 50;
        } else if (source === 'combined') {
          totalScore += 30;
        }
        
        const averageScore = fieldCount > 0 ? totalScore / fieldCount : 0;
        
        return {
          overall: Math.min(100, averageScore),
          fields: fieldScores,
          level: averageScore >= 80 ? 'high' : averageScore >= 60 ? 'medium' : 'low'
        };
      }
      
      static validateCNPJ(cnpj) {
        const cleaned = cnpj.replace(/\D/g, '');
        if (cleaned.length !== 14) return false;
        
        // Validação completa de CNPJ
        let sum = 0;
        let pos = 5;
        for (let i = 0; i < 12; i++) {
          sum += cleaned[i] * pos--;
          if (pos < 2) pos = 9;
        }
        let result = sum % 11 < 2 ? 0 : 11 - (sum % 11);
        if (result != cleaned[12]) return false;
        
        sum = 0;
        pos = 6;
        for (let i = 0; i < 13; i++) {
          sum += cleaned[i] * pos--;
          if (pos < 2) pos = 9;
        }
        result = sum % 11 < 2 ? 0 : 11 - (sum % 11);
        
        return result == cleaned[13];
      }
      
      static isValidDate(dateStr) {
        const dateRegex = /^\d{2}\/\d{2}\/\d{4}$/;
        if (!dateRegex.test(dateStr)) return false;
        
        const parts = dateStr.split('/');
        const day = parseInt(parts[0]);
        const month = parseInt(parts[1]);
        const year = parseInt(parts[2]);
        
        if (year < 2000 || year > 2030) return false;
        if (month < 1 || month > 12) return false;
        if (day < 1 || day > 31) return false;
        
        return true;
      }
      
      static isValidMonetaryValue(value) {
        const valueRegex = /^\d{1,3}(\.\d{3})*,\d{2}$/;
        return valueRegex.test(value);
      }
      
      static mergeData(xmlData, ocrData) {
        const merged = {};
        
        // Para cada campo, escolhe o mais confiável
        const fields = ['cnpj_emitente', 'nome_emitente', 'data_emissao', 'numero_documento', 'valor_total', 'descricao'];
        
        fields.forEach(field => {
          if (xmlData[field] && xmlData[field].trim()) {
            merged[field] = xmlData[field];
          } else if (ocrData[field] && ocrData[field].trim()) {
            merged[field] = ocrData[field];
          } else {
            merged[field] = '';
          }
        });
        
        return merged;
      }
    }
    
    // ===== PATTERNS MELHORADOS =====
    const PATTERNS = {
      // CNPJs - captura todos os formatos
      cnpj: /\b\d{2}[\.\s]?\d{3}[\.\s]?\d{3}[\s\/]?\d{4}[\s\-]?\d{2}\b/g,
      
      // Datas - múltiplos formatos
      dateFormats: [
        /\b(\d{2}\/\d{2}\/\d{4})\b/g,
        /\b(\d{4}-\d{2}-\d{2})\b/g,
        /\b(\d{2}-\d{2}-\d{4})\b/g
      ],
      
      // Valores monetários
      money: /\b\d{1,3}(?:\.\d{3})*,\d{2}\b/g,
      
      // Placas de veículos
      placa: [
        /\b([A-Z]{3}\d[A-Z]\d{2})\b/gi,
        /\b([A-Z]{3}[-\s]?\d{4})\b/gi,
        /PLACA[:\s]*([A-Z]{3}[-\s]?\d[A-Z0-9]\d{2})/gi,
        /PLACA[:\s]*([A-Z]{3}[-\s]?\d{4})/gi
      ],
      
      // Número de documento
      docNumber: [
        /N[úu]mero\s+da\s+NFS?-?[eE]\s*[:\-]?\s*(\d{3,10})/gi,
        /N[úu]mero\s+da\s+Nota\s*[:\-]?\s*(\d{3,10})/gi,
        /N[°º]\s*NFS?-?[eE]\s*[:\-]?\s*(\d{3,10})/gi,
        /N[úu]mero\s+do\s+RPS\s*[:\-]?\s*(\d{3,10})/gi
      ],
      
      // Campos específicos para diferentes tipos de nota
      fields: {
        prestador: /(?:PRESTADOR|EMITENTE|FORNECEDOR)[\s\S]*?(?=TOMADOR|CLIENTE|DESTINAT[ÁA]RIO|$)/i,
        razaoSocial: /(?:Raz[aã]o\s+Social|Nome\/Raz[aã]o\s+Social|Empresa)\s*[:\-]\s*([^\n\r]{3,100})/i,
        nomeFantasia: /(?:Nome\s+Fantasia)\s*[:\-]\s*([^\n\r]{3,100})/i,
        servico: /(?:DESCRI[ÇC][ÃA]O\s+DOS?\s+SERVI[ÇC]OS?|DISCRIMINA[ÇC][ÃA]O)\s*[:\-]?\s*([\s\S]{10,500}?)(?=\n\s*\n|\n[A-Z]{3,}|Valor|Base|$)/gi
      }
    };
    
    // ===== INICIALIZAÇÃO DO TESSERACT =====
    async function initTesseract() {
      if (!tesseractWorker) {
        tesseractWorker = await Tesseract.createWorker();
        await tesseractWorker.loadLanguage('por+eng');
        await tesseractWorker.initialize('por+eng');
        await tesseractWorker.setParameters({
          tessedit_ocr_engine_mode: '2',
          tessedit_pageseg_mode: '1',
          preserve_interword_spaces: '1'
        });
      }
      return tesseractWorker;
    }
    
    // ===== PROCESSAMENTO DE XML =====
    async function processXML(file) {
      const text = await file.text();
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(text, "text/xml");
      
      const extractedData = {
        cnpj_emitente: '',
        nome_emitente: '',
        data_emissao: '',
        numero_documento: '',
        valor_total: '',
        descricao: ''
      };
      
      // Extração específica para NFSe XML
      const prestador = xmlDoc.querySelector('Prestador, PrestadorServico, DadosPrestador');
      if (prestador) {
        const cnpj = prestador.querySelector('Cnpj, CpfCnpj Cnpj, IdentificacaoPrestador Cnpj');
        if (cnpj) extractedData.cnpj_emitente = formatCNPJ(cnpj.textContent);
        
        const razao = prestador.querySelector('RazaoSocial, NomeRazaoSocial');
        if (razao) extractedData.nome_emitente = razao.textContent;
      }
      
      // Data de emissão
      const dataEmissao = xmlDoc.querySelector('DataEmissao, DataEmissaoNfse, DtEmissao');
      if (dataEmissao) {
        const date = new Date(dataEmissao.textContent);
        if (!isNaN(date)) {
          extractedData.data_emissao = date.toLocaleDateString('pt-BR');
        }
      }
      
      // Número
      const numero = xmlDoc.querySelector('Numero, NumeroNfse, NumeroNota');
      if (numero) extractedData.numero_documento = numero.textContent;
      
      // Valor
      const valor = xmlDoc.querySelector('ValorServicos, ValorTotalServicos, ValorTotal, ValorNfse');
      if (valor) {
        const valorNum = parseFloat(valor.textContent);
        if (!isNaN(valorNum)) {
          extractedData.valor_total = valorNum.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
      }
      
      // Descrição
      const descricao = xmlDoc.querySelector('Discriminacao, DiscriminacaoServico, ItemListaServico, Servico');
      if (descricao) extractedData.descricao = descricao.textContent.substring(0, 120);
      
      return extractedData;
    }
    
    // ===== PRÉ-PROCESSAMENTO AVANÇADO DE IMAGEM =====
    async function preprocessImageAdvanced(file) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = () => {
          // Aumenta a resolução se necessário
          const scale = Math.max(1, 2000 / Math.max(img.width, img.height));
          canvas.width = img.width * scale;
          canvas.height = img.height * scale;
          
          // Desenha a imagem escalada
          ctx.scale(scale, scale);
          ctx.drawImage(img, 0, 0);
          
          // Aplica filtros para melhorar OCR
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          // Conversão para grayscale com pesos otimizados
          for (let i = 0; i < data.length; i += 4) {
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            data[i] = gray;
            data[i + 1] = gray;
            data[i + 2] = gray;
          }
          
          // Aplicar threshold adaptativo (binarização)
          const threshold = calculateAdaptiveThreshold(data, canvas.width, canvas.height);
          for (let i = 0; i < data.length; i += 4) {
            const value = data[i] > threshold ? 255 : 0;
            data[i] = value;
            data[i + 1] = value;
            data[i + 2] = value;
          }
          
          // Aplicar sharpening suave
          applySharpening(imageData, canvas.width, canvas.height);
          
          ctx.putImageData(imageData, 0, 0);
          resolve(canvas);
        };
        
        img.src = URL.createObjectURL(file);
      });
    }
    
    function calculateAdaptiveThreshold(data, width, height) {
      let sum = 0;
      let count = 0;
      
      for (let i = 0; i < data.length; i += 4) {
        sum += data[i];
        count++;
      }
      
      return (sum / count) * 0.85; // 85% da média
    }
    
    function applySharpening(imageData, width, height) {
      const data = imageData.data;
      const output = new Uint8ClampedArray(data);
      
      const kernel = [
        0, -1, 0,
        -1, 5, -1,
        0, -1, 0
      ];
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                sum += data[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
              }
            }
            output[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));
          }
        }
      }
      
      imageData.data.set(output);
    }
    
    // ===== PROCESSAMENTO DE IMAGEM COM OCR =====
    async function processImage(file) {
      showProcessingInfo('Aplicando pré-processamento avançado na imagem...');
      
      // Pré-processamento avançado
      const processedImage = await preprocessImageAdvanced(file);
      
      showProcessingInfo('Executando OCR com Tesseract...');
      
      // OCR com Tesseract
      const worker = await initTesseract();
      const { data } = await worker.recognize(processedImage);
      
      return data.text;
    }
    
    // ===== PROCESSAMENTO DE PDF =====
    async function processPDF(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
      let fullText = '';
      
      showProcessingInfo(`Processando PDF com ${pdf.numPages} página(s)...`);
      
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        
        // Tenta extrair texto primeiro
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(item => item.str).join(' ');
        
        if (pageText.trim().length > 50) {
          // Se tem texto suficiente, usa ele
          fullText += pageText + '\n\n';
        } else {
          // Se não tem texto, converte para imagem e faz OCR
          showProcessingInfo(`Página ${i} sem texto. Aplicando OCR...`);
          
          const viewport = page.getViewport({ scale: 2.0 });
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          
          await page.render({ canvasContext: context, viewport }).promise;
          
          const worker = await initTesseract();
          const { data } = await worker.recognize(canvas);
          fullText += data.text + '\n\n';
        }
      }
      
      return fullText;
    }
    
    // ===== EXTRAÇÃO INTELIGENTE DE DADOS =====
    function extractDataFromText(text, filename) {
      console.log(`Extraindo dados de ${filename}...`);
      
      const data = {
        filename: filename,
        cnpj_emitente: extractCNPJEmitente(text),
        nome_emitente: '',
        data_emissao: extractDataEmissao(text),
        numero_documento: extractDocumentNumber(text),
        valor_total: extractValorTotal(text),
        descricao: extractDescription(text)
      };
      
      // Extrai nome do emitente com múltiplas estratégias
      if (data.cnpj_emitente) {
        data.nome_emitente = extractEmitenteName(text, data.cnpj_emitente);
      }
      
      console.log('Dados extraídos:', data);
      return data;
    }
    
    // ===== FUNÇÕES DE EXTRAÇÃO ESPECÍFICAS =====
    function extractCNPJEmitente(text) {
      const cnpjMatches = [...text.matchAll(PATTERNS.cnpj)];
      const companyCnpjClean = COMPANY_CNPJ.replace(/\D/g, '');
      
      // Prioriza CNPJs que aparecem primeiro ou em seções de prestador
      const prestadorSection = text.match(PATTERNS.fields.prestador);
      if (prestadorSection) {
        const cnpjInSection = [...prestadorSection[0].matchAll(PATTERNS.cnpj)];
        if (cnpjInSection.length > 0) {
          const cnpj = cnpjInSection[0][0];
          const cnpjClean = cnpj.replace(/\D/g, '');
          if (cnpjClean !== companyCnpjClean && DataValidator.validateCNPJ(cnpjClean)) {
            return formatCNPJ(cnpjClean);
          }
        }
      }
      
      // Busca em todo o documento
      for (const match of cnpjMatches) {
        const cnpj = match[0];
        const cnpjClean = cnpj.replace(/\D/g, '');
        
        if (cnpjClean !== companyCnpjClean && DataValidator.validateCNPJ(cnpjClean)) {
          return formatCNPJ(cnpjClean);
        }
      }
      
      return '';
    }
    
    function extractEmitenteName(text, cnpj) {
      if (!cnpj) return '';
      
      // Verifica cache
      const cached = DataCache.getEmitente(cnpj);
      if (cached && cached.nome) {
        return cached.nome;
      }
      
      let bestName = '';
      let bestScore = 0;
      
      // Estratégia 1: Busca por campos rotulados
      const labeledPatterns = [
        PATTERNS.fields.razaoSocial,
        PATTERNS.fields.nomeFantasia
      ];
      
      for (const pattern of labeledPatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
          const name = cleanName(match[1]);
          const score = scoreNameQuality(name);
          if (score > bestScore) {
            bestName = name;
            bestScore = score;
          }
        }
      }
      
      // Estratégia 2: Busca por proximidade ao CNPJ
      if (bestScore < 80) {
        const cnpjIndex = text.indexOf(cnpj.replace(/\D/g, ''));
        if (cnpjIndex !== -1) {
          const contextStart = Math.max(0, cnpjIndex - 500);
          const contextEnd = Math.min(text.length, cnpjIndex + 300);
          const context = text.substring(contextStart, contextEnd);
          
          const lines = context.split(/[\r\n]+/).filter(l => l.trim().length > 5);
          
          for (const line of lines) {
            if (isBusinessName(line)) {
              const name = cleanName(line);
              const score = scoreNameQuality(name);
              if (score > bestScore) {
                bestName = name;
                bestScore = score;
              }
            }
          }
        }
      }
      
      // Cache o resultado
      if (bestName) {
        DataCache.setEmitente(cnpj, { nome: bestName });
      }
      
      return bestName;
    }
    
    function extractDataEmissao(text) {
      // Busca por datas com contexto
      const dateContextPatterns = [
        /(?:Data\s+de\s+)?Emiss[aã]o\s*[:\-]?\s*(\d{2}\/\d{2}\/\d{4})/gi,
        /(?:Data\s+do\s+)?[Ff]ato\s+[Gg]erador\s*[:\-]?\s*(\d{2}\/\d{2}\/\d{4})/gi,
        /(?:Emitida?\s+em|Data)\s*[:\-]?\s*(\d{2}\/\d{2}\/\d{4})/gi
      ];
      
      for (const pattern of dateContextPatterns) {
        const match = text.match(pattern);
        if (match && DataValidator.isValidDate(match[1])) {
          return match[1];
        }
      }
      
      // Busca geral por datas
      for (const pattern of PATTERNS.dateFormats) {
        const matches = [...text.matchAll(pattern)];
        for (const match of matches) {
          const date = match[1];
          if (DataValidator.isValidDate(formatDate(date))) {
            return formatDate(date);
          }
        }
      }
      
      return '';
    }
    
    function extractDocumentNumber(text) {
      // Busca por padrões específicos
      for (const pattern of PATTERNS.docNumber) {
        const matches = [...text.matchAll(pattern)];
        if (matches.length > 0) {
          return matches[0][1];
        }
      }
      
      // Busca por números em contexto
      const numberContext = /(?:N[úu]mero|N[°º]|Nota|NFS-?e|RPS)\s*[:\-]?\s*(\d{3,10})/gi;
      const match = text.match(numberContext);
      if (match) {
        return match[1];
      }
      
      return '';
    }
    
    function extractValorTotal(text) {
      // Busca por valores com contexto
      const valueContextPatterns = [
        /Valor\s+(?:Total|dos?\s+Servi[çc]os?|L[íi]quido)\s*[:\-]?\s*(?:R\$\s*)?(\d{1,3}(?:\.\d{3})*,\d{2})/gi,
        /Total\s+(?:da\s+Nota|NFS-?e|Geral)\s*[:\-]?\s*(?:R\$\s*)?(\d{1,3}(?:\.\d{3})*,\d{2})/gi
      ];
      
      for (const pattern of valueContextPatterns) {
        const match = text.match(pattern);
        if (match) {
          return match[1];
        }
      }
      
      // Busca geral - pega o maior valor
      const moneyMatches = [...text.matchAll(PATTERNS.money)];
      if (moneyMatches.length > 0) {
        const values = moneyMatches.map(match => ({
          original: match[0],
          numeric: parseFloat(match[0].replace(/\./g, '').replace(',', '.'))
        }));
        
        const maxValue = values.reduce((max, current) => 
          current.numeric > max.numeric ? current : max
        );
        
        return maxValue.original;
      }
      
      return '';
    }
    
    function extractDescription(text) {
      let bestDescription = '';
      
      // Busca por descrição de serviços
      const servicePatterns = [
        PATTERNS.fields.servico,
        /(?:Servi[çc]os?\s+Prestados?|Discrimina[çc][ãa]o)\s*[:\-]?\s*([\s\S]{10,300}?)(?=\n\s*\n|Valor|Total|$)/gi
      ];
      
      for (const pattern of servicePatterns) {
        const matches = [...text.matchAll(pattern)];
        if (matches.length > 0) {
          let desc = matches[0][1]
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
          
          // Remove valores e informações desnecessárias
          desc = desc.replace(/(?:valor|quantidade|al[íi]quota|base).*$/i, '').trim();
          
          if (desc.length > 10) {
            bestDescription = desc;
            break;
          }
        }
      }
      
      // Busca por placa se for serviço automotivo
      const placa = extractPlaca(text);
      if (placa) {
        if (bestDescription) {
          bestDescription = `${placa} - ${bestDescription.toLowerCase()}`;
        } else {
          bestDescription = `${placa} - serviços automotivos`;
        }
      }
      
      // Limita o tamanho
      if (bestDescription.length > 120) {
        bestDescription = bestDescription.substring(0, 117) + '...';
      }
      
      return bestDescription || 'Serviços';
    }
    
    function extractPlaca(text) {
      for (const pattern of PATTERNS.placa) {
        const matches = [...text.matchAll(pattern)];
        for (const match of matches) {
          let placa = match[1] || match[0];
          placa = placa.toUpperCase().replace(/[-\s]/g, '');
          
          if (isValidPlaca(placa)) {
            return formatPlaca(placa);
          }
        }
      }
      return '';
    }
    
    // ===== FUNÇÕES AUXILIARES =====
    function formatCNPJ(cnpj) {
      return cnpj.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
    }
    
    function formatDate(dateStr) {
      if (dateStr.includes('-')) {
        const parts = dateStr.split('-');
        if (parts[0].length === 4) {
          return `${parts[2]}/${parts[1]}/${parts[0]}`;
        } else {
          return dateStr.replace(/-/g, '/');
        }
      }
      return dateStr;
    }
    
    function formatPlaca(placa) {
      if (placa.length === 7) {
        if (/^[A-Z]{3}\d[A-Z]\d{2}$/.test(placa)) {
          // Mercosul
          return placa.substring(0, 3) + '-' + placa.substring(3);
        } else {
          // Antiga
          return placa.substring(0, 3) + '-' + placa.substring(3);
        }
      }
      return placa;
    }
    
    function isValidPlaca(placa) {
      return /^[A-Z]{3}\d[A-Z]\d{2}$/.test(placa) || /^[A-Z]{3}\d{4}$/.test(placa);
    }
    
    function cleanName(name) {
      return name
        .replace(/^\W+|\W+$/g, '')
        .replace(/\s+/g, ' ')
        .replace(/\s*-\s*(?:ME|EPP|LTDA|EIRELI)\s*$/i, '')
        .trim();
    }
    
    function isBusinessName(text) {
      const businessIndicators = /(LTDA|EPP|MEI|EIRELI|S\.?A|SERVI[ÇC]OS|COM[ÉE]RCIO|IND[ÚU]STRIA)/i;
      const invalidIndicators = /(CPF|CNPJ|TOMADOR|CONSUMIDOR|NOTA|DATA|VALOR|TELEFONE|EMAIL|CEP|ENDERE[ÇC]O)/i;
      
      return text.length > 5 && 
             text.length < 100 && 
             businessIndicators.test(text) && 
             !invalidIndicators.test(text) &&
             !/^\d+$/.test(text) &&
             /[A-Za-z]/.test(text);
    }
    
    function scoreNameQuality(name) {
      let score = 50; // Base score
      
      if (name.length > 10) score += 10;
      if (name.length > 20) score += 10;
      if (/LTDA|EPP|MEI|EIRELI|S\.?A/i.test(name)) score += 20;
      if (/[A-Z][a-z]/.test(name)) score += 10; // Mixed case
      
      return Math.min(100, score);
    }
    
    // ===== INTERFACE E CONTROLES =====
    function showProcessingInfo(message) {
      const infoSection = document.getElementById('processingInfo');
      const details = document.getElementById('processingDetails');
      
      infoSection.style.display = 'block';
      details.textContent = message;
    }
    
    function hideProcessingInfo() {
      document.getElementById('processingInfo').style.display = 'none';
    }
    
    function showProgress() {
      document.getElementById('progressSection').style.display = 'block';
    }
    
    function hideProgress() {
      document.getElementById('progressSection').style.display = 'none';
    }
    
    function updateProgress(current, total, message) {
      const percentage = Math.round((current / total) * 100);
      document.getElementById('progressFill').style.width = percentage + '%';
      document.getElementById('progressText').textContent = `${message} (${current}/${total})`;
    }
    
    function showResults() {
      document.getElementById('resultsSection').style.display = 'block';
    }
    
    function addRowToTable(data, confidence) {
      const tbody = document.querySelector('#resultsTable tbody');
      const row = document.createElement('tr');
      
      const confidenceIndicator = `<span class="confidence-indicator confidence-${confidence.level}" 
        title="Confiança: ${confidence.overall.toFixed(0)}%"></span>`;
      
      row.innerHTML = `
        <td contenteditable="true">${data.cnpj_emitente || ''}</td>
        <td contenteditable="true">${data.nome_emitente || ''}</td>
        <td contenteditable="true">${data.data_emissao || ''}</td>
        <td contenteditable="true">${data.numero_documento || ''}</td>
        <td contenteditable="true">${data.valor_total || ''}</td>
        <td contenteditable="true">${data.descricao || ''}</td>
        <td>${confidenceIndicator}</td>
        <td>
          <button class="delete-btn" onclick="deleteRow(this)" title="Excluir linha">
            <i class="fas fa-trash"></i>
          </button>
        </td>
      `;
      
      tbody.appendChild(row);
    }
    
    function deleteRow(button) {
      const row = button.closest('tr');
      const index = Array.from(row.parentNode.children).indexOf(row);
      
      row.remove();
      extractedData.splice(index, 1);
      enableExportIfAny();
    }
    
    function enableExportIfAny() {
      const hasData = document.querySelector('#resultsTable tbody tr');
      document.getElementById('exportBtn').disabled = !hasData;
    }
    
    function exportToExcel() {
      const table = document.getElementById('resultsTable');
      const rows = Array.from(table.querySelectorAll('tbody tr'));
      
      const data = rows.map(row => {
        const cells = Array.from(row.querySelectorAll('td[contenteditable]'));
        return {
          'CNPJ Emitente': cells[0].textContent.trim(),
          'Nome Emitente': cells[1].textContent.trim(),
          'Data Emissão': cells[2].textContent.trim(),
          'Nº Documento': cells[3].textContent.trim(),
          'Valor Total': cells[4].textContent.trim(),
          'Descrição': cells[5].textContent.trim()
        };
      });
      
      const ws = XLSX.utils.json_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Despesas');
      
      const now = new Date();
      const filename = `despesas_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.xlsx`;
      
      XLSX.writeFile(wb, filename);
    }
    
    function toggleDebug() {
      debugMode = !debugMode;
      const debugSection = document.getElementById('debugSection');
      debugSection.style.display = debugMode ? 'block' : 'none';
    }
    
    function updateDebugText(data) {
      const debugText = JSON.stringify(data, null, 2);
      document.getElementById('debugText').textContent = debugText;
    }
    
    // ===== VERIFICAÇÃO DE BIBLIOTECAS =====
    function checkLibraries() {
      const statusSection = document.getElementById('statusSection');
      const statusMessage = document.getElementById('statusMessage');
      
      statusSection.style.display = 'block';
      
      let allLoaded = true;
      let message = '';
      
      if (typeof pdfjsLib === 'undefined') {
        console.error('PDF.js não carregado');
        message += 'PDF.js não carregado. ';
        allLoaded = false;
      }
      
      if (typeof Tesseract === 'undefined') {
        console.error('Tesseract.js não carregado');
        message += 'Tesseract.js não carregado. ';
        allLoaded = false;
      }
      
      if (typeof XLSX === 'undefined') {
        console.error('SheetJS não carregado');
        message += 'SheetJS não carregado. ';
        allLoaded = false;
      }
      
      if (allLoaded) {
        statusMessage.innerHTML = '<i class="fas fa-check-circle"></i> Sistema pronto para uso!';
        statusMessage.className = 'status-ok';
        librariesLoaded = true;
        
        setTimeout(() => {
          statusSection.style.display = 'none';
        }, 3000);
        
        console.log('Todas as bibliotecas carregadas com sucesso');
      } else {
        statusMessage.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Erro: ${message}`;
        statusMessage.className = 'status-error';
        librariesLoaded = false;
        
        console.error('Erro no carregamento das bibliotecas:', message);
      }
      
      return allLoaded;
    }
    
    // ===== PROCESSAMENTO PRINCIPAL =====
    async function handleFiles(files) {
      if (!librariesLoaded) {
        alert('Aguarde o carregamento das bibliotecas!');
        return;
      }
      
      totalFiles = files.length;
      processedFiles = 0;
      extractedData = [];
      
      showProgress();
      
      // Separa arquivos por tipo
      const xmlFiles = [];
      const imageFiles = [];
      const pdfFiles = [];
      
      for (const file of files) {
        if (file.name.toLowerCase().endsWith('.xml')) {
          xmlFiles.push(file);
        } else if (file.type.startsWith('image/')) {
          imageFiles.push(file);
        } else if (file.type === 'application/pdf') {
          pdfFiles.push(file);
        }
      }
      
      // Processa XMLs primeiro (mais confiáveis)
      for (let i = 0; i < xmlFiles.length; i++) {
        const file = xmlFiles[i];
        updateProgress(processedFiles, totalFiles, `Processando XML: ${file.name}...`);
        
        try {
          const xmlData = await processXML(file);
          if (xmlData.cnpj_emitente || xmlData.numero_documento) {
            const confidence = DataValidator.calculateConfidence(xmlData, 'xml');
            extractedData.push({ ...xmlData, confidence, source: 'xml' });
            addRowToTable(xmlData, confidence);
            
            if (debugMode) {
              updateDebugText(xmlData);
            }
          }
        } catch (error) {
          console.error(`Erro ao processar XML ${file.name}:`, error);
        }
        
        processedFiles++;
      }
      
      // Processa PDFs e imagens
      const ocrFiles = [...pdfFiles, ...imageFiles];
      
      for (let i = 0; i < ocrFiles.length; i++) {
        const file = ocrFiles[i];
        updateProgress(processedFiles, totalFiles, `Processando ${file.name}...`);
        
        try {
          let extractedText = '';
          
          if (file.type === 'application/pdf') {
            extractedText = await processPDF(file);
          } else {
            extractedText = await processImage(file);
          }
          
          if (extractedText) {
            const ocrData = extractDataFromText(extractedText, file.name);
            
            // Verifica se já existe dados XML para este documento
            const existingXmlData = extractedData.find(item => 
              item.numero_documento === ocrData.numero_documento && 
              item.source === 'xml'
            );
            
            if (existingXmlData) {
              // Faz merge dos dados
              const mergedData = DataValidator.mergeData(existingXmlData, ocrData);
              const confidence = DataValidator.calculateConfidence(mergedData, 'combined');
              
              // Atualiza a linha existente
              const index = extractedData.indexOf(existingXmlData);
              extractedData[index] = { ...mergedData, confidence, source: 'combined' };
              
              showProcessingInfo('Dados validados com XML e OCR combinados!');
            } else {
              // Adiciona apenas dados OCR
              const confidence = DataValidator.calculateConfidence(ocrData, 'ocr');
              extractedData.push({ ...ocrData, confidence, source: 'ocr' });
              addRowToTable(ocrData, confidence);
            }
            
            if (debugMode) {
              updateDebugText({ text: extractedText.substring(0, 1000), data: ocrData });
            }
          }
        } catch (error) {
          console.error(`Erro ao processar ${file.name}:`, error);
        }
        
        processedFiles++;
      }
      
      updateProgress(totalFiles, totalFiles, 'Processamento concluído!');
      setTimeout(() => {
        hideProgress();
        hideProcessingInfo();
      }, 2000);
      
      enableExportIfAny();
      showResults();
    }
    
    // ===== EVENT LISTENERS =====
    document.addEventListener('DOMContentLoaded', function() {
      const fileInput = document.getElementById('fileInput');
      const uploadSection = document.getElementById('uploadSection');
      const exportBtn = document.getElementById('exportBtn');
      
      fileInput.addEventListener('change', function(e) {
        if (e.target.files.length > 0) {
          handleFiles(Array.from(e.target.files));
        }
      });
      
      // Drag and drop
      uploadSection.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadSection.classList.add('dragover');
      });
      
      uploadSection.addEventListener('dragleave', function(e) {
        e.preventDefault();
        uploadSection.classList.remove('dragover');
      });
      
      uploadSection.addEventListener('drop', function(e) {
        e.preventDefault();
        uploadSection.classList.remove('dragover');
        
        const files = Array.from(e.dataTransfer.files).filter(file => 
          file.type === 'application/pdf' || 
          file.type.startsWith('image/') ||
          file.name.toLowerCase().endsWith('.xml')
        );
        
        if (files.length > 0) {
          handleFiles(files);
        }
      });
      
      exportBtn.addEventListener('click', exportToExcel);
    });
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', async () => {
      if (tesseractWorker) {
        await tesseractWorker.terminate();
      }
    });
  </script>
</body>
</html>
