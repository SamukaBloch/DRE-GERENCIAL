Entendi. Voc√™ est√° me dizendo que, mesmo com as melhorias, o aplicativo ainda pode ter dificuldades em extrair as informa√ß√µes corretas de algumas notas, e voc√™ gostaria de uma forma de 'ensinar' o aplicativo a corrigir esses erros para futuras notas do mesmo fornecedor. Essa √© uma excelente ideia e √© totalmente poss√≠vel de implementar!

A ideia de ter um "banco de dados" local (usando `localStorage`) para associar o CNPJ do fornecedor ao nome correto que voc√™ digitou √© perfeita. Assim, da pr√≥xima vez que uma nota com aquele CNPJ for processada, o aplicativo poder√° consultar seu "conhecimento" e preencher o nome automaticamente com a sua corre√ß√£o.

Vou implementar essa funcionalidade. O que farei √© o seguinte:

1.  **Armazenar CNPJ e Nome Corrigido:** O aplicativo passar√° a guardar no `localStorage` um mapeamento entre o CNPJ do prestador e o nome que voc√™ validou ou corrigiu na tabela.
2.  **Priorizar Nomes Aprendidos:** Na pr√≥xima vez que uma nota for processada, se o CNPJ do prestador for reconhecido e j√° tiver um nome associado no seu "banco de dados" local, esse nome ser√° usado com prioridade, ignorando o que o OCR extraiu.
3.  **Atualiza√ß√£o Cont√≠nua:** Sempre que voc√™ corrigir um nome na tabela e validar a linha, o aplicativo atualizar√° ou adicionar√° essa informa√ß√£o ao seu "conhecimento".

Isso tornar√° o sistema mais inteligente e preciso ao longo do tempo, adaptando-se aos seus fornecedores espec√≠ficos.

Vou gerar o c√≥digo com essa modifica√ß√£o. Por favor, substitua o conte√∫do do seu arquivo HTML por este novo c√≥digo.

Ocorreu um erro ao tentar gerar o c√≥digo. Pe√ßo desculpas por isso. O problema foi na forma como o c√≥digo HTML foi encapsulado.

Vou corrigir e fornecer o c√≥digo HTML completo novamente. Por favor, substitua todo o conte√∫do do seu arquivo HTML por este novo c√≥digo.

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <title>Automatizador NFS-e Precis√£o Laser ‚Äì Santom√©</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    /* ====== Vari√°veis de cor ====== */
    :root {
      --primary-color: #304ffe;
      --secondary-color: #eef2ff;
      --border-color: #d9d9d9;
      --success-color: #00c853;
      --error-color: #d32f2f;
      --warning-color: #ff9800;
      --light-text: #666;
      --bg-color: #f8f9fa;
      --card-bg: #ffffff;
      --shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-color: #1a1a1a;
        --card-bg: #2d2d2d;
        --border-color: #404040;
        --light-text: #ccc;
      }
    }

    /* Garantir que a tabela sempre tenha fundo claro */
    .table-container {
      background-color: #ffffff !important;
    }

    table {
      background-color: #ffffff !important;
    }

    th, td {
      background-color: #ffffff !important;
      color: #333333 !important;
    }

    th {
      background-color: #f0f4ff !important;
    }

    /* Reset e base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: var(--bg-color);
      color: #333;
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      background: linear-gradient(135deg, #ff6b35, #f7931e);
      color: white;
      padding: 2rem 0;
      text-align: center;
      box-shadow: var(--shadow);
    }

    header h1 {
      font-size: 2.5rem;
      font-weight: 300;
      margin-bottom: 0.5rem;
    }

    header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .version-badge {
      background: rgba(255,255,255,0.2);
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      margin-top: 0.5rem;
      display: inline-block;
    }

    /* Main container */
    main {
      flex: 1;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
      width: 100%;
    }

    /* Status section */
    .status-section {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: var(--shadow);
      text-align: center;
      display: none;
    }

    .status-ok {
      color: var(--success-color);
    }

    .status-error {
      color: var(--error-color);
    }

    .status-warning {
      color: var(--warning-color);
    }

    /* Upload section */
    .upload-section {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow);
      border: 2px dashed var(--border-color);
      transition: all 0.3s ease;
    }

    .upload-section.dragover {
      border-color: #ff6b35;
      background-color: #fff5f0;
      transform: scale(1.02);
    }

    .upload-area {
      text-align: center;
      padding: 3rem 2rem;
      cursor: pointer;
      border-radius: 8px;
      transition: background-color 0.3s ease;
    }

    .upload-area:hover {
      background-color: #fff5f0;
    }

    .upload-icon {
      font-size: 4rem;
      color: #ff6b35;
      margin-bottom: 1rem;
    }

    .upload-text {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      color: #333;
    }

    .upload-hint {
      color: var(--light-text);
      font-size: 0.9rem;
    }

    #fileInput {
      display: none;
    }

    /* NOVA: Camera section */
    .camera-section {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow);
      text-align: center;
      display: none;
    }

    .camera-controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }

    .camera-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
    }

    .camera-btn:hover:not(:disabled) {
      background: #283593;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 53, 147, 0.3);
    }

    .camera-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    #cameraVideo {
      width: 100%;
      max-width: 500px;
      border-radius: 8px;
      margin: 1rem 0;
      box-shadow: var(--shadow);
      display: none;
    }

    #captureCanvas {
      display: none;
    }

    /* Upload buttons container */
    .upload-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }

    .upload-toggle-btn {
      background: var(--success-color);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
    }

    .upload-toggle-btn:hover:not(:disabled) {
      background: #4caf50;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }

    .upload-toggle-btn.active {
      background: var(--warning-color);
    }

    .upload-toggle-btn.active:hover {
      background: #f57c00;
    }

    /* Progress section */
    .progress-section {
      margin-top: 1.5rem;
      display: none;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background-color: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b35, #f7931e);
      width: 0%;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 0.9rem;
      color: var(--light-text);
      text-align: center;
    }

    /* Results section */
    .results-section {
      display: none;
      background: var(--card-bg);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: var(--shadow);
    }

    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .results-title {
      font-size: 1.5rem;
      color: #333;
    }

    .export-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .export-btn, .clear-btn, .save-btn {
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
    }

    .export-btn {
      background: var(--success-color);
      color: white;
    }

    .export-btn:hover:not(:disabled) {
      background: #4caf50;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }

    .clear-btn {
      background: var(--warning-color);
      color: white;
    }

    .clear-btn:hover:not(:disabled) {
      background: #f57c00;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 124, 0, 0.3);
    }

    .save-btn {
      background: var(--primary-color);
      color: white;
    }

    .save-btn:hover:not(:disabled) {
      background: #283593;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 53, 147, 0.3);
    }

    .export-btn:disabled, .clear-btn:disabled, .save-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    /* Table container */
    .table-container {
      overflow-x: auto;
      margin-bottom: 20px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      position: relative;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      background: var(--card-bg);
    }

    th, td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
      vertical-align: top;
    }

    th {
      background: var(--secondary-color);
      font-weight: 600;
      color: #333;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    td[contenteditable="true"] {
      border: 2px solid transparent;
      border-radius: 4px;
      transition: border-color 0.3s ease;
      cursor: text;
    }

    td[contenteditable="true"]:hover {
      border-color: #ff6b35;
      background-color: #fff5f0;
    }

    td[contenteditable="true"]:focus {
      outline: none;
      border-color: #ff6b35;
      background-color: white;
    }

    .error-row {
      background-color: #ffebee;
    }

    .error-row td {
      color: var(--error-color);
    }

    .success-row {
      background-color: #e8f5e8;
    }

    .warning-row {
      background-color: #fff3e0;
    }

    .delete-btn, .validate-btn {
      border: none;
      padding: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      margin-right: 0.5rem;
      transition: all 0.3s ease;
    }

    .delete-btn {
      background: var(--error-color);
      color: white;
    }

    .delete-btn:hover {
      background: #c62828;
      transform: scale(1.1);
    }

    .validate-btn {
      background: var(--success-color);
      color: white;
    }

    .validate-btn:hover {
      background: #4caf50;
      transform: scale(1.1);
    }

    /* Statistics section */
    .stats-section {
      display: none;
      background: var(--card-bg);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .stat-card {
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      border-left: 4px solid var(--primary-color);
    }

    .stat-number {
      font-size: 2rem;
      font-weight: bold;
      color: var(--primary-color);
    }

    .stat-label {
      color: var(--light-text);
      font-size: 0.9rem;
    }

    /* Filter section */
    .filter-section {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: var(--shadow);
      display: none;
    }

    .filter-controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .filter-input {
      padding: 0.5rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .filter-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .filter-btn:hover {
      background: #283593;
    }

    /* Debug section */
    .debug-section {
      margin-top: 2rem;
      background: #f5f5f5;
      border-radius: 8px;
      padding: 1rem;
      display: none;
    }

    .debug-section h3 {
      margin-bottom: 1rem;
      color: #666;
    }

    .debug-text {
      font-family: monospace;
      font-size: 0.8rem;
      background: white;
      padding: 1rem;
      border-radius: 4px;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .extraction-details {
      margin-top: 1rem;
      background: white;
      padding: 1rem;
      border-radius: 4px;
      border-left: 4px solid #ff6b35;
    }

    .extraction-step {
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      background: #f9f9f9;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.8rem;
    }

    .step-success { border-left: 3px solid #4caf50; }
    .step-fail { border-left: 3px solid #f44336; }
    .step-warning { border-left: 3px solid #ff9800; }

    /* Error handling */
    .error-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--error-color);
      color: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: var(--shadow);
      z-index: 1000;
      display: none;
      max-width: 400px;
    }

    .success-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--success-color);
      color: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: var(--shadow);
      z-index: 1000;
      display: none;
      max-width: 400px;
    }

    /* Footer */
    footer {
      background: #333;
      color: white;
      text-align: center;
      padding: 1.5rem;
      margin-top: 2rem;
    }

    footer a {
      color: #ff6b35;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    /* Loading spinner */
    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #ff6b35;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 0.5rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Responsive design */
    @media (max-width: 768px) {
      header h1 {
        font-size: 2rem;
      }
      
      main {
        padding: 1rem;
      }
      
      .upload-section,
      .results-section,
      .camera-section {
        padding: 1.5rem;
      }
      
      .upload-area {
        padding: 2rem 1rem;
      }
      
      .upload-icon {
        font-size: 3rem;
      }
      
      .results-header {
        flex-direction: column;
        align-items: stretch;
      }
      
      .export-buttons {
        justify-content: center;
      }
      
      table {
        font-size: 0.8rem;
      }
      
      th, td {
        padding: 0.5rem;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }

      .filter-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .upload-buttons,
      .camera-controls {
        flex-direction: column;
        align-items: stretch;
      }

      #cameraVideo {
        max-width: 100%;
      }
    }

    @media (max-width: 360px) {
      header {
        padding: 1.5rem 0;
      }
      
      header h1 {
        font-size: 1.8rem;
      }
      
      .upload-section,
      .results-section,
      .camera-section {
        padding: 1rem;
      }
      
      .upload-area {
        padding: 1.5rem 0.5rem;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1><i class="fas fa-bullseye"></i> Automatizador NFS-e v4.0</h1>
    <p>Sistema Ultra-Direto com OCR Melhorado + Extra√ß√£o Completa</p>
    <div class="version-badge">v4.0 Melhorado</div>
  </header>

  <main>
    <!-- Status Section -->
    <section class="status-section" id="statusSection">
      <div id="statusMessage">Carregando sistema ultra-direto...</div>
    </section>

    <!-- Statistics Section -->
    <section class="stats-section" id="statsSection">
      <h3>üìä Estat√≠sticas de Processamento</h3>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalProcessed">0</div>
          <div class="stat-label">Documentos Processados</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="successRate">0%</div>
          <div class="stat-label">Taxa de Sucesso</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="totalValue">R$ 0,00</div>
          <div class="stat-label">Valor Total</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="uniqueCompanies">0</div>
          <div class="stat-label">Empresas Diferentes</div>
        </div>
      </div>
    </section>

    <!-- Filter Section -->
    <section class="filter-section" id="filterSection">
      <h3>üîç Filtros</h3>
      <div class="filter-controls">
        <input type="text" class="filter-input" id="filterCompany" placeholder="Filtrar por empresa...">
        <input type="date" class="filter-input" id="filterDateFrom" placeholder="Data de...">
        <input type="date" class="filter-input" id="filterDateTo" placeholder="Data at√©...">
        <button class="filter-btn" onclick="applyFilters()">Aplicar Filtros</button>
        <button class="filter-btn" onclick="clearFilters()">Limpar Filtros</button>
      </div>
    </section>

    <!-- Upload Section -->
    <section class="upload-section" id="uploadSection">
      <!-- Bot√µes de altern√¢ncia -->
      <div class="upload-buttons">
        <button class="upload-toggle-btn active" id="fileUploadBtn" onclick="switchToFileUpload()">
          <i class="fas fa-file-upload"></i>
          Upload de Arquivos
        </button>
        <button class="upload-toggle-btn" id="cameraUploadBtn" onclick="switchToCamera()">
          <i class="fas fa-camera"></i>
          Tirar Foto da Nota
        </button>
      </div>

      <div class="upload-area" id="fileUploadArea" onclick="document.getElementById('fileInput').click()">
        <div class="upload-icon">
          <i class="fas fa-bullseye"></i>
        </div>
        <div class="upload-text">Upload de NFS-e</div>
        <div class="upload-hint">Arraste as notas ou clique para fazer o upload</div>
      </div>
      <input type="file" id="fileInput" multiple accept=".pdf,image/*">
      
      <div class="progress-section" id="progressSection">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">Aplicando extra√ß√£o ultra-direta...</div>
      </div>
    </section>

    <!-- Camera Section -->
    <section class="camera-section" id="cameraSection">
      <h3><i class="fas fa-camera"></i> Capturar Foto da NFS-e</h3>
      <div class="camera-controls">
        <button class="camera-btn" id="startCameraBtn" onclick="startCamera()">
          <i class="fas fa-video"></i>
          Ativar C√¢mera
        </button>
        <button class="camera-btn" id="captureBtn" onclick="capturePhoto()" disabled>
          <i class="fas fa-camera"></i>
          Capturar Foto
        </button>
        <button class="camera-btn" id="stopCameraBtn" onclick="stopCamera()" disabled>
          <i class="fas fa-stop"></i>
          Parar C√¢mera
        </button>
      </div>
      <video id="cameraVideo" autoplay muted playsinline></video>
      <canvas id="captureCanvas"></canvas>
    </section>

    <!-- Results Section -->
    <section class="results-section" id="resultsSection">
      <div class="results-header">
        <h2 class="results-title">Resultados Ultra-Diretos</h2>
        <div class="export-buttons">
          <button class="export-btn" id="exportBtn" disabled>
            <i class="fas fa-file-excel"></i>
            Exportar Excel
          </button>
          <button class="save-btn" id="saveBtn" disabled>
            <i class="fas fa-save"></i>
            Salvar Dados
          </button>
          <button class="clear-btn" id="clearBtn" disabled>
            <i class="fas fa-trash"></i>
            Limpar Tudo
          </button>
        </div>
      </div>
      
      <div class="table-container">
        <table id="resultsTable">
          <thead>
            <tr>
              <th>CNPJ Prestador</th>
              <th>Nome Prestador</th>
              <th>Complemento</th>
              <th>N¬∫ Nota</th>
              <th>Data/Hora</th>
              <th>Valor Servi√ßo</th>
              <th>Descri√ß√£o</th>
              <th>Placa</th>
              <th>Status</th>
              <th>A√ß√µes</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Debug Section -->
    <section class="debug-section" id="debugSection">
      <h3>Debug Ultra-Direto - An√°lise Completa v4.0</h3>
      <div class="debug-text" id="debugText"></div>
      <div class="extraction-details" id="extractionDetails"></div>
    </section>
  </main>

  <!-- Notifications -->
  <div class="error-notification" id="errorNotification">
    <i class="fas fa-exclamation-triangle"></i>
    <span id="errorMessage"></span>
  </div>

  <div class="success-notification" id="successNotification">
    <i class="fas fa-check-circle"></i>
    <span id="successMessage"></span>
  </div>

  <footer>
    <p>&copy; 2025 COMERCIO DE BANANAS SANTOM√â | 
    <a href="#" onclick="toggleDebug(); return false;">Debug Ultra-Direto</a> |
    <a href="#" onclick="toggleStats(); return false;">Estat√≠sticas</a> |
    <a href="#" onclick="toggleFilters(); return false;">Filtros</a></p>
  </footer>

  <!-- Script Melhorado v4.0 -->
  <script type="module">
    // ===== POLYFILLS =====
    (function() {
      const originalMatchAll = String.prototype.matchAll;
      String.prototype.matchAll = function(re) {
        if (re instanceof RegExp && !re.flags.includes('g')) {
          re = new RegExp(re.source, re.flags + 'g');
        }
        return originalMatchAll.call(this, re);
      };
    })();

    // Importa as bibliotecas CORRIGIDAS
    import * as pdfjsLib from './libs/pdf.min.mjs';
    import Tesseract from './libs/tesseract.esm.min.js';
    import * as XLSX from './libs/xlsx.mjs';

    // Configura PDF.js CORRIGIDO
    pdfjsLib.GlobalWorkerOptions.workerSrc = './libs/pdf.worker.min.mjs';
    window.pdfjsLib = pdfjsLib;
    window.Tesseract = Tesseract;
    window.XLSX = XLSX;

    // ===== VARI√ÅVEIS GLOBAIS =====
    let debugMode = false;
    let librariesLoaded = false;
    let extractionResults = [];
    let debugSteps = [];
    let originalResults = [];
    let statistics = {
      totalProcessed: 0,
      successCount: 0,
      errorCount: 0,
      totalValue: 0,
      uniqueCompanies: new Set()
    };
    
    // Vari√°veis para c√¢mera
    let cameraStream = null;
    let cameraMode = false;
    
    // CNPJ da empresa (tomador)
    const COMPANY_CNPJ = '07.925.317/0001-88';

    // ===== SISTEMA DE EXTRA√á√ÉO v4.0 MELHORADO =====
    class UltraDirectExtractor {
      constructor() {
        this.debugSteps = [];
        // Base de conhecimento de empresas conhecidas expandida
        // AGORA: knownCompaniesMap armazena CNPJ -> Nome da Empresa
        this.knownCompaniesMap = {}; 
        this.loadLearnedCompanies(); // Carrega empresas aprendidas ao iniciar
        
        // Padr√µes de placas brasileiras
        this.placaPatterns = [
          /\b[A-Z]{3}[\s\-]?\d{4}\b/g, // Formato antigo: AAA-1234
          /\b[A-Z]{3}[\s\-]?\d[A-Z]\d{2}\b/g, // Formato Mercosul: AAA1A23
          /(?:PLACA|VE[√çI]CULO)[:\s]*([A-Z]{3}[\s\-]?\d[A-Z\d]{3})/gi
        ];
      }

      logStep(type, message, result = null) {
        const step = { type, message, result, timestamp: new Date() };
        this.debugSteps.push(step);
        console.log(`[${type.toUpperCase()}] ${message}`, result || '');
      }

      // ===== EXTRA√á√ÉO DE CNPJ/CPF DO PRESTADOR =====
      extractPrestadorCPFCNPJ(text) {
        this.logStep('info', 'Iniciando extra√ß√£o de CPF/CNPJ do Prestador');
        
        // Remove o CNPJ da empresa tomadora para n√£o confundir
        const companyCnpjClean = COMPANY_CNPJ.replace(/\D/g, '');
        
        // Estrat√©gias espec√≠ficas para prestador
        const strategies = [
          // 1. Busca na se√ß√£o PRESTADOR
          () => {
            const prestadorMatch = text.match(/PRESTADOR[\s\S]*?(?=TOMADOR|DISCRIMINA[√áC][√ÉA]O|$)/gi);
            if (prestadorMatch) {
              const prestadorSection = prestadorMatch[0];
              
                            // Busca CNPJ na se√ß√£o prestador
              const cnpjMatches = [...prestadorSection.matchAll(/\b\d{2}[\.\s]?\d{3}[\.\s]?\d{3}[\s\/]?\d{4}[\s\-]?\d{2}\b/g)];
              for (const match of cnpjMatches) {
                const cnpj = match[0];
                const cnpjClean = cnpj.replace(/\D/g, '');
                if (cnpjClean !== companyCnpjClean && cnpjClean.length === 14) {
                  return this.formatCNPJ(cnpjClean);
                }
              }
              
              // Busca CPF na se√ß√£o prestador
              const cpfMatches = [...prestadorSection.matchAll(/\b\d{3}[\.\s]?\d{3}[\.\s]?\d{3}[\s\-]?\d{2}\b/g)];
              for (const match of cpfMatches) {
                const cpf = match[0];
                const cpfClean = cpf.replace(/\D/g, '');
                if (cpfClean.length === 11 && this.validateCPF(cpfClean)) {
                  return this.formatCPF(cpfClean);
                }
              }
            }
            return null;
          },
          
          // 2. Busca por padr√µes espec√≠ficos
          () => {
            const patterns = [
              /(?:CPF\/CNPJ|CNPJ\/CPF)[:\s]*(\d{2}[\.\s]?\d{3}[\.\s]?\d{3}[\s\/]?\d{4}[\s\-]?\d{2})/gi,
              /(?:CPF\/CNPJ|CNPJ\/CPF)[:\s]*(\d{3}[\.\s]?\d{3}[\.\s]?\d{3}[\s\-]?\d{2})/gi,
              /Prestador[^:]*CPF\/CNPJ[:\s]*(\d{2,3}[\.\s]?\d{3}[\.\s]?\d{3}[\s\/]?\d{2,4}[\s\-]?\d{2})/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const document = match[1];
                const documentClean = document.replace(/\D/g, '');
                
                if (documentClean.length === 14 && documentClean !== companyCnpjClean) {
                  return this.formatCNPJ(documentClean);
                } else if (documentClean.length === 11 && this.validateCPF(documentClean)) {
                  return this.formatCPF(documentClean);
                }
              }
            }
            return null;
          },
          
          // 3. Busca geral excluindo o da empresa
          () => {
            const allCnpjs = [...text.matchAll(/\b\d{2}[\.\s]?\d{3}[\.\s]?\d{3}[\s\/]?\d{4}[\s\-]?\d{2}\b/g)];
            for (const match of allCnpjs) {
              const cnpj = match[0];
              const cnpjClean = cnpj.replace(/\D/g, '');
              if (cnpjClean !== companyCnpjClean && cnpjClean.length === 14) {
                return this.formatCNPJ(cnpjClean);
              }
            }
            
            const allCpfs = [...text.matchAll(/\b\d{3}[\.\s]?\d{3}[\.\s]?\d{3}[\s\-]?\d{2}\b/g)];
            for (const match of allCpfs) {
              const cpf = match[0];
              const cpfClean = cpf.replace(/\D/g, '');
              if (cpfClean.length === 11 && this.validateCPF(cpfClean)) {
                return this.formatCPF(cpfClean);
              }
            }
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'CPF/CNPJ do prestador encontrado', result);
            return result;
          }
        }
        
        this.logStep('fail', 'CPF/CNPJ do prestador n√£o encontrado');
        return '';
      }

      // ===== EXTRA√á√ÉO DE COMPLEMENTO DO PRESTADOR =====
      extractPrestadorComplemento(text) {
        this.logStep('info', 'Iniciando extra√ß√£o de complemento do prestador');
        
        const strategies = [
          // 1. Busca espec√≠fica por "Complemento:"
          () => {
            const match = text.match(/Complemento[:\s]*([^\r\n]+)/gi);
            if (match) {
              const complemento = this.cleanAddressField(match[0]);
              if (complemento && complemento.length > 2) {
                return complemento;
              }
            }
            return null;
          },
          
          // 2. Busca na se√ß√£o PRESTADOR
          () => {
            const prestadorMatch = text.match(/PRESTADOR[\s\S]*?(?=TOMADOR|DISCRIMINA[√áC][√ÉA]O|$)/gi);
            if (prestadorMatch) {
              const prestadorSection = prestadorMatch[0];
              
              const complementoMatch = prestadorSection.match(/Complemento[:\s]*([^\r\n]+)/gi);
              if (complementoMatch) {
                const complemento = this.cleanAddressField(complementoMatch[0]);
                if (complemento && complemento.length > 2) {
                  return complemento;
                }
              }
            }
            return null;
          },
          
          // 3. Busca por padr√µes de endere√ßo
          () => {
            const patterns = [
              /(?:Apto|Apart|Apartamento|Sala|Loja|Andar)[:\s]*([^\r\n]+)/gi,
              /(?:Bl|Bloco|Ed|Edificio|Torre)[:\s]*([^\r\n]+)/gi,
              /(?:Casa|Resid√™ncia)[:\s]*(\d+[^\r\n]*)/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const complemento = this.cleanAddressField(match[1]);
                if (complemento && complemento.length > 2) {
                  return complemento;
                }
              }
            }
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'Complemento do prestador encontrado', result);
            return result;
          }
        }
        
        this.logStep('fail', 'Complemento do prestador n√£o encontrado');
        return '';
      }

      // ===== EXTRA√á√ÉO DE N√öMERO DA NOTA MELHORADO =====
      extractNumeroNota(text) {
        this.logStep('info', 'Iniciando extra√ß√£o MELHORADA de n√∫mero da nota');

        const strategies = [
          // 1. Busca espec√≠fica para "N√∫mero da nota"
          () => {
            const patterns = [
              /N[√∫u]mero\s+da\s+(?:nota|NFS?-?e)[\s:\n\r]*(\d{3,10})/gi,
              /Nota\s+(?:Fiscal\s+)?(?:de\s+)?Servi[√ßc]o\s+(?:Eletr[√¥o]nica\s+)?(?:n[√∫u]mero\s+)?(\d{3,10})/gi,
              /NFS?-?e\s+(?:n[√∫u]mero\s+)?(\d{3,10})/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const number = match[1];
                if (this.validateDocumentNumber(number)) {
                  return number;
                }
              }
            }
            return null;
          },
          
          // 2. Busca em estrutura de tabela
          () => {
            const tableMatch = text.match(/(?:N[√∫u]mero\s+do\s+)?RPS\s+N[√∫u]mero\s+da\s+(?:nota|NFS?-?e)[\s\S]*?(\d{3,6})\s+(\d{3,10})/gi);
            if (tableMatch) {
              const numbers = tableMatch[0].match(/(\d{3,10})/g);
              if (numbers && numbers.length >= 2) {
                const noteNumber = numbers[1];
                if (this.validateDocumentNumber(noteNumber)) {
                  return noteNumber;
                }
              }
            }
            return null;
          },
          
          // 3. Busca por padr√£o sequencial
          () => {
            const patterns = [
              /(\d{4,6})\s+(\d{4,10})\s+\d{2}\/\d{2}\/\d{4}/g,
              /(?:RPS|rps)[:\s]*(\d{4,6})[^\d]*(\d{4,10})/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                if (match.length >= 3) {
                  const possibleNoteNumber = match[2];
                  if (this.validateDocumentNumber(possibleNoteNumber)) {
                    return possibleNoteNumber;
                  }
                }
              }
            }
            return null;
          },
          
          // 4. Busca por contexto NFS-e
          () => {
            const lines = text.split(/[\r\n]+/);
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              if (/(?:nota|nfs-?e|documento)/gi.test(line)) {
                // Procura n√∫mero na mesma linha ou pr√≥ximas
                for (let j = 0; j <= 2 && (i + j) < lines.length; j++) {
                  const searchLine = lines[i + j];
                  const numberMatch = searchLine.match(/\b(\d{4,10})\b/);
                  if (numberMatch && this.validateDocumentNumber(numberMatch[1])) {
                    return numberMatch[1];
                  }
                }
              }
            }
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'N√∫mero da nota encontrado', result);
            return result;
          }
        }

        this.logStep('fail', 'N√∫mero da nota n√£o encontrado');
        return '';
      }

      // ===== EXTRA√á√ÉO DE DATA/HORA MELHORADA =====
      extractDataHoraEmissao(text) {
        this.logStep('info', 'Iniciando extra√ß√£o MELHORADA de data/hora de emiss√£o');
        
        const strategies = [
          // 1. Data e hora completas
          () => {
            const patterns = [
              /(?:Data.*?emiss[√£a]o|Emitida\s+em)[:\s]*(\d{2}\/\d{2}\/\d{4})\s+(?:√†s\s+)?(\d{2}:\d{2}(?::\d{2})?)/gi,
              /(\d{2}\/\d{2}\/\d{4})\s+(\d{2}:\d{2}(?::\d{2})?)/g,
              /(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}(?::\d{2})?)/g
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const date = match[1];
                const time = match[2];
                if (this.isValidDate(date)) {
                  return `${this.formatDate(date)} ${time}`;
                }
              }
            }
            return null;
          },
          
          // 2. Apenas data (busca mais espec√≠fica)
          () => {
            const patterns = [
              /(?:Data.*?emiss[√£a]o|Emitida\s+em)[:\s]*(\d{2}\/\d{2}\/\d{4})/gi,
              /(?:Compet√™ncia|Per√≠odo)[:\s]*(\d{2}\/\d{2}\/\d{4})/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const date = match[1];
                if (this.isValidDate(date)) {
                  return this.formatDate(date);
                }
              }
            }
            return null;
          },
          
          // 3. Busca geral por datas v√°lidas
          () => {
            const datePatterns = [
              /\b(\d{2}\/\d{2}\/\d{4})\b/g,
              /\b(\d{4}-\d{2}-\d{2})\b/g,
              /\b(\d{2}-\d{2}-\d{4})\b/g
            ];
            
            for (const pattern of datePatterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const date = match[1];
                if (this.isValidDate(date) && this.isRecentDate(date)) {
                  return this.formatDate(date);
                }
              }
            }
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'Data/hora de emiss√£o encontrada', result);
            return result;
          }
        }
        
        this.logStep('fail', 'Data/hora de emiss√£o n√£o encontrada');
        return '';
      }

      // ===== EXTRA√á√ÉO DE VALOR DO SERVI√áO MELHORADA =====
      extractValorServico(text) {
        this.logStep('info', 'Iniciando extra√ß√£o MELHORADA de valor do servi√ßo');
        
        const strategies = [
          // 1. Busca espec√≠fica por "Valor do Servi√ßo"
          () => {
            const patterns = [
              /Valor\s+(?:do\s+|dos\s+)?Servi[√ßc]o[s]?[:\s]*((?:R\$\s*)?[\d\.,]+)/gi,
              /Valor\s+L[i√≠]quido[:\s]*((?:R\$\s*)?[\d\.,]+)/gi,
              /Base\s+de\s+C[√°a]lculo[:\s]*((?:R\$\s*)?[\d\.,]+)/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const value = this.cleanMoneyValue(match[1]);
                if (value && this.validateMoneyValue(value)) {
                  return value;
                }
              }
            }
            return null;
          },
          
          // 2. Busca na se√ß√£o de valores
          () => {
            const valorSection = text.match(/(?:Valor|Total|Servi√ßo)[\s\S]{0,200}?(?:R\$\s*)?(\d{1,6}(?:\.\d{3})*,\d{2})/gi);
            if (valorSection) {
              for (const section of valorSection) {
                const valueMatch = section.match(/((?:R\$\s*)?\d{1,6}(?:\.\d{3})*,\d{2})/g);
                if (valueMatch) {
                  const value = this.cleanMoneyValue(valueMatch[valueMatch.length - 1]);
                  if (value && this.validateMoneyValue(value)) {
                    return value;
                  }
                }
              }
            }
            return null;
          },
          
          // 3. Busca por padr√£o monet√°rio brasileiro
          () => {
            const moneyMatches = [...text.matchAll(/(?:R\$\s*)?(\d{1,6}(?:\.\d{3})*,\d{2})\b/g)];
            
            if (moneyMatches.length === 0) return null;
            
            // Filtra valores muito pequenos ou muito grandes
            const validValues = moneyMatches
              .map(match => this.cleanMoneyValue(match[1]))
              .filter(value => this.validateMoneyValue(value))
              .sort((a, b) => {
                const numA = parseFloat(a.replace(/\./g, '').replace(',', '.'));
                const numB = parseFloat(b.replace(/\./g, '').replace(',', '.'));
                return numB - numA; // Ordem decrescente
              });
            
            if (validValues.length > 0) {
              return validValues[0]; // Retorna o maior valor
            }
            
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'Valor do servi√ßo encontrado', result);
            return result;
          }
        }
        
        this.logStep('fail', 'Valor do servi√ßo n√£o encontrado');
        return '';
      }

      // ===== EXTRA√á√ÉO DE DESCRI√á√ÉO MELHORADA =====
      extractDescricaoServico(text) {
        this.logStep('info', 'Iniciando extra√ß√£o MELHORADA de descri√ß√£o do servi√ßo');
        
        const strategies = [
          // 1. Busca espec√≠fica por discrimina√ß√£o
          () => {
            const patterns = [
              /DISCRIMINA[√áC][√ÉA]O\s+DOS?\s+SERVI[√áC]OS?[:\s]*([\s\S]{10,500}?)(?=\n\s*\n|\n[A-Z]{3,}|Valor|Observa|$)/gi,
              /Descri[√ßc][√£a]o\s+do\s+Servi[√ßc]o[:\s]*([\s\S]{10,500}?)(?=\n\s*\n|\n[A-Z]{3,}|Valor|Observa|$)/gi,
              /Servi[√ßc]os?\s+(?:Prestados?|Executados?)[:\s]*([\s\S]{10,500}?)(?=\n\s*\n|\n[A-Z]{3,}|Valor|Observa|$)/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const description = this.cleanServiceDescription(match[1]);
                if (description && description.length > 10) {
                  return description;
                }
              }
            }
            return null;
          },
          
          // 2. Busca por se√ß√£o de descri√ß√£o
          () => {
            const lines = text.split(/[\r\n]+/);
            let inDescriptionSection = false;
            let description = '';
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              
              if (/(?:DISCRIMINA[√áC][√ÉA]O|Descri[√ßc][√£a]o|Servi[√ßc]os)/gi.test(line)) {
                inDescriptionSection = true;
                continue;
              }
              
              if (inDescriptionSection) {
                if (/^(?:Valor|Total|Observa|Dados|TOMADOR|Base)/gi.test(line)) {
                  break;
                }
                
                if (line.length > 5 && !/^[\d\s\-\.]+$/.test(line)) {
                  description += line + ' ';
                }
              }
            }
            
            if (description.trim().length > 10) {
              return this.cleanServiceDescription(description.trim());
            }
            
            return null;
          },
          
          // 3. Busca por palavras-chave de servi√ßos
          () => {
            const serviceKeywords = [
              'servi√ßo', 'reparo', 'manuten√ß√£o', 'instala√ß√£o', 'conserto',
              'troca', 'substitui√ß√£o', 'limpeza', 'pintura', 'soldagem',
              'montagem', 'desmontagem', 'revis√£o', 'an√°lise', 'diagn√≥stico',
              'consultoria', 'assessoria', 'transporte', 'frete', 'entrega',
              'hospedagem', 'alimenta√ß√£o', 'combust√≠vel', 'lavagem',
              'balanceamento', 'alinhamento', 'lubrifica√ß√£o'
            ];
            
            const lines = text.split(/[\r\n]+/);
            for (const line of lines) {
              const cleanLine = line.trim();
              if (cleanLine.length > 15 && cleanLine.length < 200) {
                const hasServiceKeyword = serviceKeywords.some(keyword => 
                  new RegExp(keyword, 'gi').test(cleanLine)
                );
                
                if (hasServiceKeyword && !/^[\d\s\-\.\/]+$/.test(cleanLine)) {
                  const description = this.cleanServiceDescription(cleanLine);
                  if (description.length > 10) {
                    return description;
                  }
                }
              }
            }
            
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'Descri√ß√£o do servi√ßo encontrada', result);
            return result;
          }
        }
        
        this.logStep('warning', 'Descri√ß√£o espec√≠fica n√£o encontrada, usando padr√£o');
        return 'Servi√ßos diversos';
      }

      // ===== EXTRA√á√ÉO DE PLACA =====
      extractPlacaVeiculo(text) {
        this.logStep('info', 'Iniciando extra√ß√£o de placa de ve√≠culo');
        
        const strategies = [
          // 1. Busca espec√≠fica por "Placa:"
          () => {
            const patterns = [
              /(?:Placa|Ve[√≠i]culo)[:\s]*([A-Z]{3}[\s\-]?\d[A-Z\d]{3})/gi,
              /(?:Placa|Ve[√≠i]culo)[:\s]*([A-Z]{3}[\s\-]?\d{4})/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const placa = this.cleanPlaca(match[1]);
                if (this.validatePlaca(placa)) {
                  return placa;
                }
              }
            }
            return null;
          },
          
          // 2. Busca por padr√µes de placa isolados
          () => {
            for (const pattern of this.placaPatterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const placa = this.cleanPlaca(match[0]);
                if (this.validatePlaca(placa)) {
                  return placa;
                }
              }
            }
            return null;
          },
          
          // 3. Busca contextual pr√≥xima a palavras relacionadas
          () => {
            const lines = text.split(/[\r\n]+/);
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              if (/(?:ve[√≠i]culo|placa|carro|caminh√£o|moto)/gi.test(line)) {
                // Procura placa na mesma linha ou pr√≥ximas
                for (let j = 0; j <= 2 && (i + j) < lines.length; j++) {
                  const searchLine = lines[i + j];
                  for (const pattern of this.placaPatterns) {
                    const matches = [...searchLine.matchAll(pattern)];
                    for (const match of matches) {
                      const placa = this.cleanPlaca(match[0]);
                      if (this.validatePlaca(placa)) {
                        return placa;
                      }
                    }
                  }
                }
              }
            }
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'Placa de ve√≠culo encontrada', result);
            return result;
          }
        }
        
        this.logStep('info', 'Placa de ve√≠culo n√£o encontrada');
        return '';
      }

      // ===== EXTRA√á√ÉO DE NOME DO PRESTADOR MELHORADA =====
      extractPrestadorNome(text, cnpj) {
        this.logStep('info', 'Iniciando extra√ß√£o MELHORADA de nome do prestador');
        
        if (!cnpj) {
          this.logStep('fail', 'CNPJ n√£o fornecido para busca de nome');
          return '';
        }

        // NOVO: Prioriza o nome aprendido se o CNPJ for conhecido
        const cleanedCnpj = cnpj.replace(/\D/g, '');
        if (this.knownCompaniesMap[cleanedCnpj]) {
          const learnedName = this.knownCompaniesMap[cleanedCnpj];
          this.logStep('success', 'Nome do prestador encontrado via aprendizado', learnedName);
          return learnedName;
        }

        const strategies = [
          // 1. Empresas espec√≠ficas conhecidas (se ainda n√£o estiver no mapa)
          () => {
            const specificCompanies = [
              /GIVA\s+CARDANS[^0-9\n\r]*LTDA[^0-9\n\r]*ME/gi,
              /TRIO\s+DELICIA\s+DELIVERY[^0-9\n\r]*LTDA/gi,
              /IMUNIZADORA\s+JARAGUA[^0-9\n\r]*LTDA/gi,
              /VANTOIR\s+DERETTI[^0-9\n\r]*ME/gi,
              /SERVOPA\s+CAMINHOES[^0-9\n\r]*LTDA/gi,
              /TRANSPOTECH\s+PECAS\s+E\s+SERVICOS[^0-9\n\r]*LTDA/gi,
              /SINDICATO.*COMERCIO.*VAREJISTA/gi,
              /FSC\s+COMUNICACOES[^0-9\n\r]*LTDA/gi
            ];
            
            for (const pattern of specificCompanies) {
              const match = text.match(pattern);
              if (match) {
                const name = this.cleanCompanyName(match[0]);
                if (this.validateCompanyNameImproved(name)) {
                  // N√£o precisa chamar learnCompany aqui, pois o validateCompanyNameImproved j√° faz isso
                  return name;
                }
              }
            }
            return null;
          },
          
          // 2. Busca na se√ß√£o PRESTADOR
          () => {
            const prestadorMatch = text.match(/PRESTADOR\s+DE\s+SERVI[√áC]OS([\s\S]*?)(?=TOMADOR|DISCRIMINA[√áC][√ÉA]O|$)/gi);
            if (prestadorMatch) {
              const prestadorSection = prestadorMatch[0];
              
              // Busca Raz√£o Social
              const razaoMatch = prestadorSection.match(/(?:Raz[√£a]o\s+Social|Nome)[:\s]*([^\r\n]+)/gi);
              if (razaoMatch) {
                const name = this.cleanCompanyName(razaoMatch[0]);
                if (this.validateCompanyNameImproved(name)) {
                  return name;
                }
              }
              
              // Busca linha com empresa
              const prestadorLines = prestadorSection.split(/[\r\n]+/).map(l => l.trim()).filter(l => l.length > 0);
              for (const line of prestadorLines) {
                if (line.length > 15 && line.length < 120 && 
                    /LTDA|EPP|S\.?A|ME|EIRELI/gi.test(line) &&
                    !/PRESTADOR|TOMADOR|ENDERE√áO|TELEFONE|EMAIL|CPF|CNPJ|Inscri√ß√£o/i.test(line)) {
                  
                  const name = this.cleanCompanyName(line);
                  if (this.validateCompanyNameImproved(name)) {
                    return name;
                  }
                }
              }
            }
            return null;
          },
          
          // 3. Busca por padr√µes espec√≠ficos
          () => {
            const patterns = [
              /(?:Nome\/Raz[√£a]o\s+social|Raz[√£a]o\s+Social|Nome\s+Fantasia)[:\s]*([^\r\n]+)/gi,
              /Prestador[^:]*[:\s]*([^\r\n]+(?:LTDA|EPP|S\.?A|ME|EIRELI)[^\r\n]*)/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...text.matchAll(pattern)];
              for (const match of matches) {
                const name = this.cleanCompanyName(match[1]);
                if (this.validateCompanyNameImproved(name)) {
                  return name;
                }
              }
            }
            return null;
          },
          
          // 4. Busca por CNPJ e nome pr√≥ximo
          () => {
            const cnpjPattern = new RegExp(cnpj.replace(/[^\d]/g, '').replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1\\.$2\\.$3/$4-$5'));
            const cnpjIndex = text.search(cnpjPattern);
            
            if (cnpjIndex > -1) {
              const beforeCnpj = text.substring(Math.max(0, cnpjIndex - 300), cnpjIndex);
              const afterCnpj = text.substring(cnpjIndex, cnpjIndex + 300);
              
              const sections = [beforeCnpj, afterCnpj];
              
              for (const section of sections) {
                const companyMatch = section.match(/([A-Z][^0-9\n\r]{5,80}(?:LTDA|EPP|S\.?A|ME|EIRELI)[^0-9\n\r]{0,20})/gi);
                if (companyMatch) {
                  const name = this.cleanCompanyName(companyMatch[0]);
                  if (this.validateCompanyNameImproved(name)) {
                    return name;
                  }
                }
              }
            }
            return null;
          }
        ];

        for (const strategy of strategies) {
          const result = strategy();
          if (result) {
            this.logStep('success', 'Nome do prestador encontrado', result);
            // Se encontrou por OCR, adiciona ao aprendizado
            this.learnCompany(cleanedCnpj, result);
            return result;
          }
        }

        this.logStep('fail', 'Nome do prestador n√£o encontrado');
        return '';
      }

      // ===== M√âTODOS DE VALIDA√á√ÉO E FORMATA√á√ÉO =====
      validateCPF(cpf) {
        if (cpf.length !== 11 || /^(\d)\1{10}$/.test(cpf)) return false;
        
        let sum = 0;
        for (let i = 0; i < 9; i++) {
          sum += parseInt(cpf.charAt(i)) * (10 - i);
        }
        let remainder = 11 - (sum % 11);
        if (remainder === 10 || remainder === 11) remainder = 0;
        if (remainder !== parseInt(cpf.charAt(9))) return false;
        
        sum = 0;
        for (let i = 0; i < 10; i++) {
          sum += parseInt(cpf.charAt(i)) * (11 - i);
        }
        remainder = 11 - (sum % 11);
        if (remainder === 10 || remainder === 11) remainder = 0;
        if (remainder !== parseInt(cpf.charAt(10))) return false;
        
        return true;
      }

      formatCPF(cpf) {
        return cpf.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
      }

      formatCNPJ(cnpj) {
        return cnpj.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
      }

      cleanAddressField(text) {
        return text
          .replace(/^(Complemento:|complemento:)/gi, '')
          .replace(/[\r\n]+/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      }

      validateDocumentNumber(number) {
        if (!number) return false;
        const clean = number.toString().replace(/\D/g, '');
        
                  if (clean.length < 3 || clean.length > 10) return false;
          if (parseInt(clean) < 100) return false;
          
          const num = parseInt(clean);
          if (num >= 2020 && num <= 2030) return false; // Evita confundir com anos
          
          if (/^0+$/.test(clean) || /^1+$/.test(clean)) return false; // Evita n√∫meros como 0000 ou 1111
          
          return true;
        }

        isValidDate(dateStr) {
          const formats = [
            /^\d{2}\/\d{2}\/\d{4}$/,
            /^\d{4}-\d{2}-\d{2}$/,
            /^\d{2}-\d{2}-\d{4}$/
          ];
          
          if (!formats.some(format => format.test(dateStr))) return false;
          
          let parts;
          if (dateStr.includes('/')) {
            parts = dateStr.split('/');
            if (parts[0].length === 4) {
              parts = [parts[2], parts[1], parts[0]]; // YYYY/MM/DD -> DD/MM/YYYY
            }
          } else {
            const dashParts = dateStr.split('-');
            if (dashParts[0].length === 4) {
              parts = [dashParts[2], dashParts[1], dashParts[0]]; // YYYY-MM-DD -> DD/MM/YYYY
            } else {
              parts = dashParts; // DD-MM-YYYY
            }
          }
          
          const day = parseInt(parts[0]);
          const month = parseInt(parts[1]);
          const year = parseInt(parts[2]);
          
          if (year < 2020 || year > 2030) return false; // Ajuste o range de anos conforme necess√°rio
          if (month < 1 || month > 12) return false;
          if (day < 1 || day > 31) return false;
          
          return true;
        }

        isRecentDate(dateStr) {
          const currentYear = new Date().getFullYear();
          const yearInDate = parseInt(dateStr.match(/\d{4}/)[0]);
          return Math.abs(currentYear - yearInDate) <= 2; // Considera datas de at√© 2 anos atr√°s/frente
        }

        formatDate(dateStr) {
          if (dateStr.includes('-')) {
            const parts = dateStr.split('-');
            if (parts[0].length === 4) {
              return `${parts[2]}/${parts[1]}/${parts[0]}`;
            } else {
              return dateStr.replace(/-/g, '/');
            }
          }
          return dateStr;
        }

        cleanMoneyValue(value) {
          if (!value) return '';
          return value
            .replace(/R\$\s*/g, '')
            .replace(/[^\d\.,]/g, '')
            .trim();
        }

        validateMoneyValue(value) {
          if (!value) return false;
          
          const numericValue = parseFloat(value.replace(/\./g, '').replace(',', '.'));
          
          return numericValue >= 1 && numericValue <= 1000000; // Valores entre R$1,00 e R$1.000.000,00
        }

        cleanServiceDescription(text) {
          return text
            .replace(/^(DISCRIMINA[√áC][√ÉA]O|Descri[√ßc][√£a]o|Servi[√ßc]os?)[^:]*:?/gi, '')
            .replace(/[\r\n]+/g, ' ')
            .replace(/\s+/g, ' ')
            .replace(/^[\s\W]+|[\s\W]+$/g, '')
            .trim()
            .substring(0, 150); // Limita o tamanho da descri√ß√£o
        }

        cleanPlaca(placa) {
          return placa
            .replace(/[\s\-]/g, '')
            .toUpperCase()
            .trim();
        }

        validatePlaca(placa) {
          if (!placa || placa.length < 7 || placa.length > 8) return false;
          
          // Formato antigo: AAA1234
          if (/^[A-Z]{3}\d{4}$/.test(placa)) return true;
          
          // Formato Mercosul: AAA1A23
          if (/^[A-Z]{3}\d[A-Z]\d{2}$/.test(placa)) return true;
          
          return false;
        }

        cleanCompanyName(name) {
          if (!name) return '';
          
          return name
            .replace(/^(Nome\/Raz√£o social:|Raz√£o Social:|Nome fantasia:|PRESTADOR:|CPF\/CNPJ:|Prestador de Servi√ßos|Raz√£o Social:)/gi, '')
            .replace(/^(e\s+|de\s+|da\s+|do\s+)/gi, '')
            .replace(/(Inscri√ß√£o|CPF\/CNPJ|Telefone|E-mail|N√∫mero da NFS-e|Situa√ß√£o|Emitida|Autenticidade|CNPJ:|N√∫mero da|CEP|Endere√ßo|Munic√≠pio|Email:|Complemento|UF:|Data Presta√ß√£o|Documento emitido).*$/gi, '')
            .replace(/(TOMADOR|COMERCIO DE BANANAS|ALAMEDA|TORRE|ANDAR|SITIO|CENTRO|MUNIC√çPIO|SECRETARIA|FAZENDA|Nota Fiscal|N√∫mero:|Data de|PRESTADOR DE|Inscrigao estadual).*$/gi, '')
            .replace(/[\r\n]+/g, ' ')
            .replace(/^[\s\W]+|[\s\W]+$/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        }

        validateCompanyNameImproved(name) {
          if (!name || name.length < 5 || name.length > 150) return false;
          if (!/[A-Za-z]/.test(name)) return false;
          if (/^[\d\s\-\.]+$/.test(name)) return false;
          
          // Filtros cr√≠ticos para evitar extrair coisas que n√£o s√£o nomes de empresas
          if (/SECRETARIA|MUNICIPAL|FAZENDA|PREFEITURA|TOMADOR|PRESTADOR|COMERCIO DE BANANAS|Optante Simples|Regime|Situa√ß√£o|Documento emitido/i.test(name)) {
            return false;
          }
          
          // Padr√µes espec√≠ficos aceitos
          const acceptedPatterns = [
            /GIVA.*CARDANS/i,
            /TRIO.*DELICIA.*DELIVERY/i,
            /IMUNIZADORA.*JARAGUA/i,
            /VANTOIR.*DERETTI/i,
            /SERVOPA.*CAMINHOES/i,
            /TRANSPOTECH.*PECAS.*SERVICOS/i,
            /SINDICATO.*COMERCIO.*VAREJISTA/i,
            /FSC.*COMUNICACOES/i,
            /EPP|LTDA|ME|EIRELI|S\.?A/i // Termos comuns em nomes de empresas
          ];

          return acceptedPatterns.some(pattern => pattern.test(name));
        }

        validateCompanyName(name) {
          return this.validateCompanyNameImproved(name);
        }

        // NOVO: Sistema de aprendizado de empresas
        learnCompany(cnpj, companyName) {
          const cleanCnpj = cnpj.replace(/\D/g, '');
          if (cleanCnpj && companyName) {
            this.knownCompaniesMap[cleanCnpj] = companyName;
            this.saveLearnedCompanies();
            this.logStep('info', 'Empresa aprendida/atualizada', { cnpj: cleanCnpj, name: companyName });
          }
        }

        saveLearnedCompanies() {
          try {
            localStorage.setItem('learned_companies_map', JSON.stringify(this.knownCompaniesMap));
          } catch (error) {
            console.warn('Erro ao salvar empresas aprendidas:', error);
          }
        }

        loadLearnedCompanies() {
          try {
            const savedCompanies = localStorage.getItem('learned_companies_map');
            if (savedCompanies) {
              this.knownCompaniesMap = JSON.parse(savedCompanies);
              this.logStep('info', `Carregadas ${Object.keys(this.knownCompaniesMap).length} empresas aprendidas`);
            }
          } catch (error) {
            console.warn('Erro ao carregar empresas aprendidas:', error);
          }
        }

        // ===== M√âTODO PRINCIPAL MELHORADO =====
        async extractAllData(text, filename) {
          this.debugSteps = [];
          this.logStep('info', `=== INICIANDO EXTRA√á√ÉO v4.0 MELHORADA PARA ${filename} ===`);
          
          // As empresas aprendidas j√° s√£o carregadas no construtor
          
          const data = {
            filename: filename,
            ocr_prestador_cpf_cnpj: '',
            ocr_prestador_nome: '',
            ocr_prestador_complemento: '',
            ocr_numero_nota: '',
            ocr_data_hora_emissao: '',
            ocr_valor_servico: '',
            ocr_descricao_servico: '',
            ocr_placa_veiculo: '',
            status: 'pending'
          };

          try {
            // Extra√ß√£o sequencial melhorada
            data.ocr_prestador_cpf_cnpj = this.extractPrestadorCPFCNPJ(text);
            
            // A extra√ß√£o do nome do prestador agora prioriza o mapa de empresas aprendidas
            if (data.ocr_prestador_cpf_cnpj) {
              data.ocr_prestador_nome = this.extractPrestadorNome(text, data.ocr_prestador_cpf_cnpj);
            }
            
            data.ocr_prestador_complemento = this.extractPrestadorComplemento(text);
            data.ocr_numero_nota = this.extractNumeroNota(text);
            data.ocr_data_hora_emissao = this.extractDataHoraEmissao(text);
            data.ocr_valor_servico = this.extractValorServico(text);
            data.ocr_descricao_servico = this.extractDescricaoServico(text);
            data.ocr_placa_veiculo = this.extractPlacaVeiculo(text);
            
            data.status = this.determineExtractionStatus(data);
            
            this.logStep('success', '=== EXTRA√á√ÉO v4.0 MELHORADA CONCLU√çDA ===', data);
            
            return data;
            
          } catch (error) {
            this.logStep('error', 'ERRO NA EXTRA√á√ÉO ULTRA-DIRETA', error.message);
            return {
              ...data,
              ocr_prestador_nome: 'ERRO ULTRA-DIRETO',
              ocr_numero_nota: 'ERRO',
              ocr_descricao_servico: error.message,
              status: 'error'
            };
          }
        }

        determineExtractionStatus(data) {
          let score = 0;
          let required = 0;
          
          // Campos obrigat√≥rios
          if (data.ocr_prestador_cpf_cnpj) { score++; required++; }
          if (data.ocr_prestador_nome && data.ocr_prestador_nome !== 'ERRO ULTRA-DIRETO') { score++; required++; }
          if (data.ocr_numero_nota && data.ocr_numero_nota !== 'ERRO') { score++; required++; }
          if (data.ocr_data_hora_emissao) { score++; required++; }
          if (data.ocr_valor_servico) { score++; required++; }
          
          // Campos opcionais (n√£o afetam muito o score)
          if (data.ocr_descricao_servico && data.ocr_descricao_servico !== 'Servi√ßos diversos') score += 0.5;
          if (data.ocr_prestador_complemento) score += 0.3;
          if (data.ocr_placa_veiculo) score += 0.2;

          const successRate = score / (required + 1); // +1 para incluir campos opcionais

          if (successRate >= 0.9) return 'success';
          if (successRate >= 0.6) return 'warning';
          return 'error';
        }
      }

      // ===== INST√ÇNCIA DO EXTRATOR =====
      const ultraDirectExtractor = new UltraDirectExtractor();

      // ===== SISTEMA DE C√ÇMERA =====
      async function startCamera() {
        try {
          const constraints = {
            video: {
              facingMode: 'environment',
              width: { ideal: 1920 },
              height: { ideal: 1080 }
            }
          };

          cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
          const videoElement = document.getElementById('cameraVideo');
          videoElement.srcObject = cameraStream;
          
          videoElement.style.display = 'block';
          document.getElementById('startCameraBtn').disabled = true;
          document.getElementById('captureBtn').disabled = false;
          document.getElementById('stopCameraBtn').disabled = false;
          
          showNotification('C√¢mera ativada com sucesso!');
          
        } catch (error) {
          console.error('Erro ao acessar c√¢mera:', error);
          showNotification('Erro ao acessar a c√¢mera: ' + error.message, 'error');
        }
      }

      async function capturePhoto() {
        try {
          const video = document.getElementById('cameraVideo');
          const canvas = document.getElementById('captureCanvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          canvas.toBlob(async (blob) => {
            try {
              showProgress();
              updateProgress(0, 1, 'Processando foto capturada...');
              
              const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
              const filename = `foto_nfse_${timestamp}.jpg`;
              
              const extractedText = await processImageImproved(blob);
              
              if (!extractedText || extractedText.trim().length < 10) {
                throw new Error('Texto insuficiente extra√≠do da foto');
              }
              
              const data = await ultraDirectExtractor.extractAllData(extractedText, filename);
              
              extractionResults.unshift(data);
              originalResults = [...extractionResults];
              renderResult(data);
              
              updateStatistics();
              enableExportIfAny();
              showResults();
              
              updateProgress(1, 1, 'Foto processada com sucesso!');
              setTimeout(hideProgress, 2000);
              
              showNotification('Foto capturada e processada com sucesso!');
              
              if (debugMode) {
                updateDebugInfo(extractedText);
              }
              
            } catch (error) {
              console.error('Erro ao processar foto:', error);
              showNotification('Erro ao processar foto: ' + error.message, 'error');
              hideProgress();
            }
          }, 'image/jpeg', 0.8);
          
        } catch (error) {
          console.error('Erro ao capturar foto:', error);
          showNotification('Erro ao capturar foto: ' + error.message, 'error');
        }
      }

      function stopCamera() {
        if (cameraStream) {
          cameraStream.getTracks().forEach(track => track.stop());
          cameraStream = null;
        }
        
        const videoElement = document.getElementById('cameraVideo');
        videoElement.style.display = 'none';
        videoElement.srcObject = null;
        
        document.getElementById('startCameraBtn').disabled = false;
        document.getElementById('captureBtn').disabled = true;
        document.getElementById('stopCameraBtn').disabled = true;
        
        showNotification('C√¢mera desativada');
      }

      function switchToFileUpload() {
        document.getElementById('fileUploadArea').style.display = 'block';
        document.getElementById('cameraSection').style.display = 'none';
        
        document.getElementById('fileUploadBtn').classList.add('active');
        document.getElementById('cameraUploadBtn').classList.remove('active');
        
        cameraMode = false;
        if (cameraStream) {
          stopCamera();
        }
      }

      function switchToCamera() {
        document.getElementById('fileUploadArea').style.display = 'none';
        document.getElementById('cameraSection').style.display = 'block';
        
        document.getElementById('fileUploadBtn').classList.remove('active');
        document.getElementById('cameraUploadBtn').classList.add('active');
        
        cameraMode = true;
      }

      // Exportar fun√ß√µes para escopo global
      window.startCamera = startCamera;
      window.capturePhoto = capturePhoto;
      window.stopCamera = stopCamera;
      window.switchToFileUpload = switchToFileUpload;
      window.switchToCamera = switchToCamera;

      // ===== SISTEMA DE NOTIFICA√á√ïES =====
      function showNotification(message, type = 'success') {
        const notification = document.getElementById(type === 'error' ? 'errorNotification' : 'successNotification');
        const messageElement = document.getElementById(type === 'error' ? 'errorMessage' : 'successMessage');
        
        messageElement.textContent = message;
        notification.style.display = 'block';
        
        setTimeout(() => {
          notification.style.display = 'none';
        }, 5000);
      }

      // ===== SISTEMA DE ESTAT√çSTICAS =====
      function updateStatistics() {
        statistics.totalProcessed = extractionResults.length;
        statistics.successCount = extractionResults.filter(r => r.status === 'success').length;
        statistics.errorCount = extractionResults.filter(r => r.status === 'error').length;
        
        statistics.totalValue = extractionResults.reduce((total, item) => {
          if (item.ocr_valor_servico && item.status !== 'error') {
            const value = parseFloat(item.ocr_valor_servico.replace(/\./g, '').replace(',', '.'));
            return total + (isNaN(value) ? 0 : value);
          }
          return total;
        }, 0);

        statistics.uniqueCompanies.clear();
        extractionResults.forEach(item => {
          if (item.ocr_prestador_nome && item.status !== 'error') {
            statistics.uniqueCompanies.add(item.ocr_prestador_nome);
          }
        });

        document.getElementById('totalProcessed').textContent = statistics.totalProcessed;
        document.getElementById('successRate').textContent = 
          statistics.totalProcessed > 0 ? 
          Math.round((statistics.successCount / statistics.totalProcessed) * 100) + '%' : '0%';
        document.getElementById('totalValue').textContent = 
          'R$ ' + statistics.totalValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 });
        document.getElementById('uniqueCompanies').textContent = statistics.uniqueCompanies.size;
      }

      // ===== SISTEMA DE FILTROS =====
      function applyFilters() {
        const companyFilter = document.getElementById('filterCompany').value.toLowerCase();
        const dateFromFilter = document.getElementById('filterDateFrom').value;
        const dateToFilter = document.getElementById('filterDateTo').value;

        let filteredResults = [...originalResults];

        if (companyFilter) {
          filteredResults = filteredResults.filter(item => 
            item.ocr_prestador_nome.toLowerCase().includes(companyFilter)
          );
        }

        if (dateFromFilter) {
          filteredResults = filteredResults.filter(item => {
            if (!item.ocr_data_hora_emissao) return false;
            const itemDate = item.ocr_data_hora_emissao.split('/').reverse().join('-').substr(0, 10);
            return itemDate >= dateFromFilter;
          });
        }

        if (dateToFilter) {
          filteredResults = filteredResults.filter(item => {
            if (!item.ocr_data_hora_emissao) return false;
            const itemDate = item.ocr_data_hora_emissao.split('/').reverse().join('-').substr(0, 10);
            return itemDate <= dateToFilter;
          });
        }

        const tbody = document.querySelector('#resultsTable tbody');
        tbody.innerHTML = '';
        filteredResults.forEach(data => renderResult(data, data.status === 'error'));

        showNotification(`Filtro aplicado: ${filteredResults.length} resultados encontrados`);
      }

      function clearFilters() {
        document.getElementById('filterCompany').value = '';
        document.getElementById('filterDateFrom').value = '';
        document.getElementById('filterDateTo').value = '';
        
        const tbody = document.querySelector('#resultsTable tbody');
        tbody.innerHTML = '';
        originalResults.forEach(data => renderResult(data, data.status === 'error'));

        showNotification('Filtros removidos');
      }

      // ===== SISTEMA DE BACKUP =====
      function saveDataToLocalStorage() {
        try {
          const dataToSave = {
            timestamp: new Date().toISOString(),
            results: extractionResults,
            statistics: {
              ...statistics,
              uniqueCompanies: Array.from(statistics.uniqueCompanies)
            },
            // NOVO: Salva tamb√©m o mapa de empresas aprendidas
            learnedCompaniesMap: ultraDirectExtractor.knownCompaniesMap 
          };
          
          localStorage.setItem('nfse_data_backup', JSON.stringify(dataToSave));
          showNotification('Dados salvos com sucesso!');
        } catch (error) {
          showNotification('Erro ao salvar dados: ' + error.message, 'error');
        }
      }

      function loadDataFromLocalStorage() {
        try {
          const savedData = localStorage.getItem('nfse_data_backup');
          if (savedData) {
            const parsedData = JSON.parse(savedData);
            
            if (confirm('Dados salvos encontrados. Deseja restaurar?')) {
              extractionResults = parsedData.results || [];
              originalResults = [...extractionResults];
              
              if (parsedData.statistics) {
                statistics = {
                  ...parsedData.statistics,
                  uniqueCompanies: new Set(parsedData.statistics.uniqueCompanies || [])
                };
              }

              // NOVO: Carrega o mapa de empresas aprendidas
              if (parsedData.learnedCompaniesMap) {
                ultraDirectExtractor.knownCompaniesMap = parsedData.learnedCompaniesMap;
                ultraDirectExtractor.logStep('info', `Carregadas ${Object.keys(ultraDirectExtractor.knownCompaniesMap).length} empresas aprendidas do backup`);
              }
              
              const tbody = document.querySelector('#resultsTable tbody');
              tbody.innerHTML = '';
              extractionResults.forEach(data => renderResult(data, data.status === 'error'));
              
              updateStatistics();
              enableExportIfAny();
              showResults();
              showNotification('Dados restaurados com sucesso!');
              
              return true;
            }
          }
        } catch (error) {
          showNotification('Erro ao carregar dados: ' + error.message, 'error');
        }
        return false;
      }

      // ===== VERIFICA√á√ÉO DE BIBLIOTECAS =====
      function checkLibraries() {
        const statusSection = document.getElementById('statusSection');
        const statusMessage = document.getElementById('statusMessage');
        
        statusSection.style.display = 'block';
        
        let allLoaded = true;
        let message = '';
        
        console.log('üîç Verificando bibliotecas v4.0...');
        
        if (typeof pdfjsLib === 'undefined') {
          console.error('‚ùå PDF.js n√£o carregado');
          message += 'PDF.js n√£o carregado. ';
          allLoaded = false;
        } else {
          console.log('‚úÖ PDF.js carregado:', pdfjsLib.version || 'vers√£o desconhecida');
          
          if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
            console.error('‚ùå PDF.js worker n√£o configurado');
            message += 'PDF.js worker n√£o configurado. ';
            allLoaded = false;
          } else {
            console.log('‚úÖ PDF.js worker configurado:', pdfjsLib.GlobalWorkerOptions.workerSrc);
          }
        }
        
        if (typeof Tesseract === 'undefined') {
          console.error('‚ùå Tesseract.js n√£o carregado');
          message += 'Tesseract.js n√£o carregado. ';
          allLoaded = false;
        } else {
          console.log('‚úÖ Tesseract.js carregado');
          
          if (typeof Tesseract.createWorker !== 'function') {
            console.error('‚ùå Tesseract.createWorker n√£o dispon√≠vel');
            message += 'Tesseract.createWorker n√£o dispon√≠vel. ';
            allLoaded = false;
          } else {
            console.log('‚úÖ Tesseract.createWorker dispon√≠vel');
          }
        }
        
        if (typeof XLSX === 'undefined') {
          console.error('‚ùå SheetJS n√£o carregado');
          message += 'SheetJS n√£o carregado. ';
          allLoaded = false;
        } else {
          console.log('‚úÖ SheetJS carregado:', XLSX.version || 'vers√£o desconhecida');
          
          if (typeof XLSX.utils === 'undefined' || typeof XLSX.writeFile !== 'function') {
            console.error('‚ùå SheetJS funcionalidades n√£o dispon√≠veis');
            message += 'SheetJS funcionalidades n√£o dispon√≠veis. ';
            allLoaded = false;
          } else {
            console.log('‚úÖ SheetJS funcionalidades dispon√≠veis');
          }
        }
        
        if (allLoaded) {
          statusMessage.innerHTML = '<i class="fas fa-check-circle"></i> Sistema v4.0 Melhorado ativo! Todas as bibliotecas carregadas. OCR aprimorado implementado.';
          statusMessage.className = 'status-ok';
          librariesLoaded = true;
          
          setTimeout(() => {
            statusSection.style.display = 'none';
          }, 3000);
          
          console.log('üéØ Sistema de Extra√ß√£o v4.0 Melhorado inicializado com sucesso!');
          
          loadDataFromLocalStorage(); // Tenta carregar dados e empresas aprendidas
          
        } else {
          statusMessage.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Erro nas bibliotecas: ${message}`;
          statusMessage.className = 'status-error';
          librariesLoaded = false;
          
          console.error('‚ùå Erro no carregamento das bibliotecas:', message);
          showNotification('Erro ao carregar bibliotecas. Verifique a pasta ./libs/', 'error');
        }
      }

      // ===== PROCESSAMENTO DE ARQUIVOS MELHORADO =====
      async function handleFiles(files) {
        console.log('üìÅ Iniciando processamento melhorado de arquivos:', files.length);
        
        if (!librariesLoaded) {
          showNotification('‚ö†Ô∏è Aguarde o carregamento do sistema ULTRA-DIRETO!', 'error');
          return;
        }
        
        const supportedFiles = Array.from(files).filter(file => {
          const isSupported = file.type === 'application/pdf' || file.type.startsWith('image/');
          if (!isSupported) {
            console.warn('‚ö†Ô∏è Arquivo n√£o suportado:', file.name, file.type);
          }
          return isSupported;
        });
        
        if (supportedFiles.length === 0) {
          showNotification('‚ùå Nenhum arquivo PDF ou imagem v√°lido encontrado', 'error');
          return;
        }
        
        if (supportedFiles.length !== files.length) {
          showNotification(`‚ö†Ô∏è ${files.length - supportedFiles.length} arquivo(s) ignorado(s) - apenas PDF e imagens s√£o suportados`, 'error');
        }
        
        showProgress();
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < supportedFiles.length; i++) {
          const file = supportedFiles[i];
          console.log(`üìÑ Processando ${i + 1}/${supportedFiles.length}: ${file.name} (${file.type})`);
          
          updateProgress(i, supportedFiles.length, `Aplicando extra√ß√£o ultra-direta melhorada em ${file.name}...`);
          
          try {
            let extractedText = '';
            
            if (file.type === 'application/pdf') {
              console.log('üìë Processando PDF melhorado:', file.name);
              extractedText = await processPDFImproved(file);
            } else if (file.type.startsWith('image/')) {
              console.log('üñºÔ∏è Processando imagem melhorada:', file.name);
              extractedText = await processImageImproved(file);
            }
            
            console.log('üìù Texto extra√≠do melhorado:', extractedText.length, 'caracteres');
            console.log('üìÑ Preview:', extractedText.substring(0, 300) + '...');
            
            if (!extractedText || extractedText.trim().length < 10) {
              throw new Error('Texto extra√≠do insuficiente ou vazio');
            }
            
            const data = await ultraDirectExtractor.extractAllData(extractedText, file.name);
            
            extractionResults.unshift(data);
            originalResults = [...extractionResults];
            renderResult(data);
            
            if (data.status === 'success') {
              successCount++;
            } else if (data.status === 'error') {
              errorCount++;
            }
            
            if (debugMode) {
              updateDebugInfo(extractedText);
            }
            
            console.log('‚úÖ Arquivo processado com sucesso:', file.name);
            
          } catch (error) {
            console.error(`‚ùå Erro ao processar ${file.name}:`, error);
            errorCount++;
            
            const errorData = {
              filename: file.name,
              ocr_prestador_cpf_cnpj: 'ERRO',
              ocr_prestador_nome: 'Erro no processamento ULTRA-DIRETO',
              ocr_prestador_complemento: '',
              ocr_numero_nota: '',
              ocr_data_hora_emissao: '',
              ocr_valor_servico: '',
              ocr_descricao_servico: error.message || 'Erro desconhecido',
              ocr_placa_veiculo: '',
              status: 'error'
            };
            
            extractionResults.unshift(errorData);
            originalResults = [...extractionResults];
            renderResult(errorData, true);
            
            showNotification(`‚ùå Erro ao processar ${file.name}: ${error.message}`, 'error');
          }
        }
        
        updateProgress(supportedFiles.length, supportedFiles.length, 'Extra√ß√£o ultra-direta melhorada conclu√≠da!');
        setTimeout(hideProgress, 2000);
        
        updateStatistics();
        enableExportIfAny();
        showResults();
        
        const totalProcessed = supportedFiles.length;
        let finalMessage = `üìä Processamento conclu√≠do: ${totalProcessed} arquivo(s)`;
        if (successCount > 0) finalMessage += ` | ‚úÖ ${successCount} sucesso`;
        if (errorCount > 0) finalMessage += ` | ‚ùå ${errorCount} erro(s)`;
        
        showNotification(finalMessage);
        console.log('üéØ Processamento finalizado:', { total: totalProcessed, success: successCount, errors: errorCount });
      }

      // ===== PROCESSAMENTO DE PDF MELHORADO =====
      async function processPDFImproved(file) {
        console.log('üìë Iniciando processamento PDF melhorado:', file.name, file.size, 'bytes');
        
        try {
          const arrayBuffer = await file.arrayBuffer();
          console.log('üìÅ ArrayBuffer criado:', arrayBuffer.byteLength, 'bytes');
          
          const pdf = await pdfjsLib.getDocument({
            data: arrayBuffer,
            useSystemFonts: true,
            standardFontDataUrl: './libs/'
          }).promise;
          console.log('üìñ PDF carregado:', pdf.numPages, 'p√°ginas');
          
          let fullText = '';

          for (let i = 1; i <= pdf.numPages; i++) {
            console.log(`üìÑ Processando p√°gina ${i}/${pdf.numPages}`);
            
            try {
              const page = await pdf.getPage(i);
              
              // Tenta extrair texto primeiro
              const textContent = await page.getTextContent({
                normalizeWhitespace: true,
                disableCombineTextItems: false
              });
              
              let pageText = textContent.items
                .map(item => {
                  // Preserva quebras de linha baseadas na posi√ß√£o
                  return {
                    str: item.str,
                    transform: item.transform,
                    width: item.width,
                    height: item.height
                  };
                })
                .sort((a, b) => {
                  // Ordena por posi√ß√£o Y (linha) e depois X (coluna)
                  const yDiff = Math.abs(a.transform[5] - b.transform[5]);
                  if (yDiff > 5) { // Nova linha
                    return b.transform[5] - a.transform[5]; // Y decrescente
                  }
                  return a.transform[4] - b.transform[4]; // X crescente
                })
                .map(item => item.str)
                .join(' ')
                .replace(/\s+/g, ' ');
              
              console.log(`üìù P√°gina ${i}: ${pageText.length} caracteres extra√≠dos via texto`);
              
              // Se n√£o conseguiu texto suficiente, tenta OCR
              if (!pageText.trim() || pageText.length < 50) {
                console.log(`üîç P√°gina ${i} sem texto suficiente, tentando OCR melhorado...`);
                pageText = await ocrImagePageImproved(pdf, i);
                console.log(`üîç OCR melhorado p√°gina ${i}: ${pageText.length} caracteres`);
                            }
              
              fullText += pageText + '\n\n';
              
            } catch (pageError) {
              console.warn(`‚ö†Ô∏è Erro na p√°gina ${i}:`, pageError);
              try {
                const pageText = await ocrImagePageImproved(pdf, i);
                fullText += pageText + '\n\n';
                console.log(`üîç OCR de emerg√™ncia melhorado p√°gina ${i}: ${pageText.length} caracteres`);
              } catch (ocrError) {
                console.error(`‚ùå Falha completa na p√°gina ${i}:`, ocrError);
              }
            }
          }

          console.log('‚úÖ PDF processado com sucesso melhorado:', fullText.length, 'caracteres totais');
          return fullText;
          
        } catch (error) {
          console.error('‚ùå Erro no processamento PDF melhorado:', error);
          throw new Error(`Erro ao processar PDF: ${error.message}`);
        }
      }

      async function ocrImagePageImproved(pdf, pageNum) {
        console.log(`üîç Iniciando OCR melhorado na p√°gina ${pageNum}`);
        
        try {
          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale: 3 }); // Maior resolu√ß√£o para melhor OCR
          const canvas = document.createElement('canvas');
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          const ctx = canvas.getContext('2d');
          
          // Configura√ß√µes para melhor qualidade
          ctx.imageSmoothingEnabled = false;
          
          await page.render({ 
            canvasContext: ctx, 
            viewport: viewport,
            renderInteractiveForms: true
          }).promise;
          
          console.log(`üñºÔ∏è Canvas renderizado melhorado: ${canvas.width}x${canvas.height}`);

          const worker = await Tesseract.createWorker();
          
          // Configura√ß√µes otimizadas para documentos brasileiros
          await worker.loadLanguage('por+eng');
          await worker.initialize('por+eng');
          
          await worker.setParameters({
            tessedit_pageseg_mode: Tesseract.PSM.AUTO,
            tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
            tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Ä√Å√Ç√É√Ñ√Ö√á√à√â√ä√ã√å√ç√é√è√ë√í√ì√î√ï√ñ√ô√ö√õ√ú√ù√†√°√¢√£√§√•√ß√®√©√™√´√¨√≠√Æ√Ø√±√≤√≥√¥√µ√∂√π√∫√ª√º√Ω .,;:!?()[]{}/"\'\\-_@#$%&*+=<>|'
          });
          
          console.log(`ü§ñ Tesseract melhorado inicializado, processando p√°gina ${pageNum}...`);

          const { data: { text } } = await worker.recognize(canvas);
          await worker.terminate();
          
          console.log(`‚úÖ OCR melhorado conclu√≠do p√°gina ${pageNum}: ${text.length} caracteres`);
          return text;
          
        } catch (error) {
          console.error(`‚ùå Erro no OCR melhorado p√°gina ${pageNum}:`, error);
          throw new Error(`Erro no OCR: ${error.message}`);
        }
      }

      // ===== PROCESSAMENTO DE IMAGEM MELHORADO =====
      async function processImageImproved(file) {
        console.log('üñºÔ∏è Iniciando processamento melhorado de imagem:', file.name || 'foto_capturada', file.type || 'image/jpeg', file.size || 'tamanho desconhecido', 'bytes');
        
        try {
          // Pr√©-processamento da imagem para melhor OCR
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();
          
          const imageUrl = URL.createObjectURL(file);
          
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = imageUrl;
          });
          
          // Redimensiona se necess√°rio mantendo propor√ß√£o
          let { width, height } = img;
          const maxDimension = 3000; // M√°ximo para boa qualidade sem explodir mem√≥ria
          
          if (width > maxDimension || height > maxDimension) {
            const ratio = Math.min(maxDimension / width, maxDimension / height);
            width *= ratio;
            height *= ratio;
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // Desenha com configura√ß√µes otimizadas
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(img, 0, 0, width, height);
          
          // Aplica filtros para melhorar OCR
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          
          // Converte para escala de cinza e aumenta contraste
          for (let i = 0; i < data.length; i += 4) {
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            
            // Aumenta contraste
            const contrast = 1.5;
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            const enhancedGray = Math.min(255, Math.max(0, factor * (gray - 128) + 128));
            
            data[i] = enhancedGray;     // R
            data[i + 1] = enhancedGray; // G
            data[i + 2] = enhancedGray; // B
            // data[i + 3] permanece como alpha
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          console.log(`üîß Imagem pr√©-processada: ${width}x${height}`);
          
          URL.revokeObjectURL(imageUrl);
          
          const { createWorker } = Tesseract;
          console.log('ü§ñ Criando worker Tesseract melhorado para imagem...');
          
          const worker = await createWorker();
          
          console.log('üìö Carregando idiomas portugu√™s e ingl√™s...');
          await worker.loadLanguage('por+eng');
          await worker.initialize('por+eng');
          
          // Configura√ß√µes otimizadas
          await worker.setParameters({
            tessedit_pageseg_mode: Tesseract.PSM.AUTO,
            tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
            tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Ä√Å√Ç√É√Ñ√Ö√á√à√â√ä√ã√å√ç√é√è√ë√í√ì√î√ï√ñ√ô√ö√õ√ú√ù√†√°√¢√£√§√•√ß√®√©√™√´√¨√≠√Æ√Ø√±√≤√≥√¥√µ√∂√π√∫√ª√º√Ω .,;:!?()[]{}/"\'\\-_@#$%&*+=<>|',
            tessedit_enable_doc_dict: 1,
            tessedit_enable_dict_correction: 1,
            language_model_penalty_non_freq_dict_word: 0.1,
            language_model_penalty_non_dict_word: 0.15
          });
          
          console.log('üîç Iniciando reconhecimento OCR melhorado...');
          const { data: { text } } = await worker.recognize(canvas);
          
          await worker.terminate();
          console.log('‚úÖ Imagem processada com sucesso melhorado:', text.length, 'caracteres extra√≠dos');
          
          return text;
          
        } catch (error) {
          console.error('‚ùå Erro no processamento melhorado de imagem:', error);
          throw new Error(`Erro ao processar imagem: ${error.message}`);
        }
      }

      // ===== INTERFACE MELHORADA =====
      function renderResult(data, isError = false) {
        const tbody = document.querySelector('#resultsTable tbody');
        const row = document.createElement('tr');
        
        if (isError || data.status === 'error') {
          row.className = 'error-row';
        } else if (data.status === 'success') {
          row.className = 'success-row';
        } else if (data.status === 'warning') {
          row.className = 'warning-row';
        }
        
        const statusIcon = data.status === 'success' ? '‚úÖ' : 
                          data.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
        
        row.innerHTML = `
          <td contenteditable="true">${data.ocr_prestador_cpf_cnpj || ''}</td>
          <td contenteditable="true">${data.ocr_prestador_nome || ''}</td>
          <td contenteditable="true">${data.ocr_prestador_complemento || ''}</td>
          <td contenteditable="true">${data.ocr_numero_nota || ''}</td>
          <td contenteditable="true">${data.ocr_data_hora_emissao || ''}</td>
          <td contenteditable="true">${data.ocr_valor_servico || ''}</td>
          <td contenteditable="true">${data.ocr_descricao_servico || ''}</td>
          <td contenteditable="true">${data.ocr_placa_veiculo || ''}</td>
          <td>${statusIcon}</td>
          <td>
            <button class="validate-btn" onclick="validateRow(this)" title="Validar linha">
              <i class="fas fa-check"></i>
            </button>
            <button class="delete-btn" onclick="deleteResult(this)" title="Excluir linha">
              <i class="fas fa-trash"></i>
            </button>
          </td>
        `;
        
        tbody.appendChild(row);
      }

      // ===== FUN√á√ïES GLOBAIS =====
      window.deleteResult = function(button) {
        const row = button.closest('tr');
        const index = Array.from(row.parentNode.children).indexOf(row);
        
        row.remove();
        extractionResults.splice(index, 1);
        originalResults = [...extractionResults];
        updateStatistics();
        enableExportIfAny();
        showNotification('Linha removida com sucesso');
      }

      window.validateRow = function(button) {
        const row = button.closest('tr');
        const cells = Array.from(row.querySelectorAll('td[contenteditable]'));
        let isValid = true;
        
        const cpfCnpj = cells[0].textContent.trim();
        const nomePrestador = cells[1].textContent.trim(); // NOVO: Pega o nome do prestador da c√©lula
        
        // Valida√ß√£o de CPF/CNPJ
        if (cpfCnpj) {
          const cleanCpfCnpj = cpfCnpj.replace(/\D/g, '');
          if (cleanCpfCnpj.length === 11) {
            if (!ultraDirectExtractor.validateCPF(cleanCpfCnpj)) {
              cells[0].style.borderColor = 'red';
              isValid = false;
            } else {
              cells[0].textContent = ultraDirectExtractor.formatCPF(cleanCpfCnpj); // Formata
              cells[0].style.borderColor = '';
            }
          } else if (cleanCpfCnpj.length === 14) {
            cells[0].textContent = ultraDirectExtractor.formatCNPJ(cleanCpfCnpj); // Formata
            cells[0].style.borderColor = '';
          } else {
            cells[0].style.borderColor = 'red';
            isValid = false;
          }
        } else {
          cells[0].style.borderColor = 'red';
          isValid = false;
        }
        
        // Valida√ß√£o do nome do prestador
        if (!nomePrestador || nomePrestador.length < 5 || !ultraDirectExtractor.validateCompanyNameImproved(nomePrestador)) {
          cells[1].style.borderColor = 'red';
          isValid = false;
        } else {
          cells[1].style.borderColor = '';
        }

        // Valida√ß√£o do n√∫mero da nota
        const numeroNota = cells[3].textContent.trim();
        if (!numeroNota || !ultraDirectExtractor.validateDocumentNumber(numeroNota)) {
          cells[3].style.borderColor = 'red';
          isValid = false;
        } else {
          cells[3].style.borderColor = '';
        }

        // Valida√ß√£o da data/hora de emiss√£o
        const dataHoraEmissao = cells[4].textContent.trim();
        if (!dataHoraEmissao || !ultraDirectExtractor.isValidDate(dataHoraEmissao.split(' ')[0])) { // Valida apenas a data
          cells[4].style.borderColor = 'red';
          isValid = false;
        } else {
          cells[4].style.borderColor = '';
        }

        // Valida√ß√£o do valor do servi√ßo
        const valorServico = cells[5].textContent.trim();
        if (!valorServico || !ultraDirectExtractor.validateMoneyValue(valorServico)) {
          cells[5].style.borderColor = 'red';
          isValid = false;
        } else {
          cells[5].style.borderColor = '';
        }

        // Valida√ß√£o da descri√ß√£o do servi√ßo (opcional, mas verifica se n√£o est√° vazia)
        const descricaoServico = cells[6].textContent.trim();
        if (!descricaoServico || descricaoServico.length < 5) {
          cells[6].style.borderColor = 'orange'; // Aviso, n√£o erro fatal
        } else {
          cells[6].style.borderColor = '';
        }

        // Valida√ß√£o da placa do ve√≠culo (opcional)
        const placaVeiculo = cells[7].textContent.trim();
        if (placaVeiculo && !ultraDirectExtractor.validatePlaca(placaVeiculo)) {
          cells[7].style.borderColor = 'orange'; // Aviso, n√£o erro fatal
        } else {
          cells[7].style.borderColor = '';
        }
        
        if (isValid) {
          row.className = 'success-row';
          showNotification('Linha validada com sucesso!');
          
          // NOVO: Aprende o nome do prestador se a linha for validada
          ultraDirectExtractor.learnCompany(cpfCnpj, nomePrestador);

        } else {
          row.className = 'error-row'; // Marca como erro se houver falha na valida√ß√£o
          showNotification('Dados da linha precisam ser corrigidos', 'error');
        }
      }

      window.toggleDebug = function() {
        debugMode = !debugMode;
        const debugSection = document.getElementById('debugSection');
        debugSection.style.display = debugMode ? 'block' : 'none';
        showNotification(debugMode ? 'Debug ativado' : 'Debug desativado');
      }

      window.toggleStats = function() {
        const statsSection = document.getElementById('statsSection');
        const isVisible = statsSection.style.display !== 'none';
        statsSection.style.display = isVisible ? 'none' : 'block';
        showNotification(isVisible ? 'Estat√≠sticas ocultadas' : 'Estat√≠sticas exibidas');
      }

      window.toggleFilters = function() {
        const filterSection = document.getElementById('filterSection');
        const isVisible = filterSection.style.display !== 'none';
        filterSection.style.display = isVisible ? 'none' : 'block';
        showNotification(isVisible ? 'Filtros ocultados' : 'Filtros exibidos');
      }

      window.applyFilters = applyFilters;
      window.clearFilters = clearFilters;

      function showProgress() {
        document.getElementById('progressSection').style.display = 'block';
      }
      
      function hideProgress() {
        document.getElementById('progressSection').style.display = 'none';
      }
      
      function updateProgress(current, total, message) {
        const percentage = Math.round((current / total) * 100);
        document.getElementById('progressFill').style.width = percentage + '%';
        document.getElementById('progressText').textContent = `${message} (${current}/${total})`;
      }
      
      function showResults() {
        document.getElementById('resultsSection').style.display = 'block';
      }
      
      function enableExportIfAny() {
        const hasData = document.querySelector('#resultsTable tbody tr');
        document.getElementById('exportBtn').disabled = !hasData;
        document.getElementById('saveBtn').disabled = !hasData;
        document.getElementById('clearBtn').disabled = !hasData;
      }

      // ===== EXPORTA√á√ÉO MELHORADA =====
      function exportToExcel() {
        const table = document.getElementById('resultsTable');
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        
        const data = rows.map(row => {
          const cells = Array.from(row.querySelectorAll('td[contenteditable]'));
          return {
            'CNPJ/CPF Prestador': cells[0].textContent.trim(),
            'Nome Prestador': cells[1].textContent.trim(),
            'Complemento': cells[2].textContent.trim(),
            'N√∫mero da Nota': cells[3].textContent.trim(),
            'Data/Hora Emiss√£o': cells[4].textContent.trim(),
            'Valor do Servi√ßo': cells[5].textContent.trim(),
            'Descri√ß√£o do Servi√ßo': cells[6].textContent.trim(),
            'Placa do Ve√≠culo': cells[7].textContent.trim()
          };
        });
        
        const ws = XLSX.utils.json_to_sheet(data);
        
        // Configura√ß√µes de largura das colunas
        ws['!cols'] = [
          { wch: 18 }, // CNPJ/CPF
          { wch: 30 }, // Nome
          { wch: 20 }, // Complemento
          { wch: 15 }, // N√∫mero
          { wch: 18 }, // Data/Hora
          { wch: 15 }, // Valor
          { wch: 40 }, // Descri√ß√£o
          { wch: 12 }  // Placa
        ];
        
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'NFS-e_Melhorado_v40');
        
        const now = new Date();
        const filename = `nfse_melhorado_v40_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.xlsx`;
        
        XLSX.writeFile(wb, filename);
        showNotification('Excel exportado com sucesso!');
      }

      function clearAllData() {
        if (confirm('Tem certeza que deseja limpar todos os dados?')) {
          extractionResults = [];
          originalResults = [];
          
          const tbody = document.querySelector('#resultsTable tbody');
          tbody.innerHTML = '';
          
          statistics = {
            totalProcessed: 0,
            successCount: 0,
            errorCount: 0,
            totalValue: 0,
            uniqueCompanies: new Set()
          };
          
          // NOVO: Limpa tamb√©m o mapa de empresas aprendidas
          ultraDirectExtractor.knownCompaniesMap = {};
          ultraDirectExtractor.saveLearnedCompanies(); // Salva o mapa vazio
          
          updateStatistics();
          enableExportIfAny();
          
          localStorage.removeItem('nfse_data_backup');
          localStorage.removeItem('learned_companies_map'); // Garante que o mapa de empresas seja limpo
          
          showNotification('Todos os dados foram limpos');
        }
      }
      
      function updateDebugInfo(text) {
        document.getElementById('debugText').textContent = text.substring(0, 2000) + (text.length > 2000 ? '\n... (texto truncado)' : '');
        
        const detailsDiv = document.getElementById('extractionDetails');
        let html = '<h4>üéØ Processo de Extra√ß√£o v4.0 Melhorado:</h4>';
        
        if (ultraDirectExtractor.debugSteps.length > 0) {
          html += '<div>';
          ultraDirectExtractor.debugSteps.forEach(step => {
            const stepClass = step.type === 'success' ? 'step-success' : 
                             step.type === 'fail' || step.type === 'error' ? 'step-fail' : 
                             step.type === 'warning' ? 'step-warning' : '';
            
            html += `<div class="extraction-step ${stepClass}">
              <strong>[${step.type.toUpperCase()}]</strong> ${step.message}
              ${step.result ? `<br><em>Resultado: ${JSON.stringify(step.result)}</em>` : ''}
            </div>`;
          });
          html += '</div>';
        }
        
        detailsDiv.innerHTML = html;
      }

      // ===== INICIALIZA√á√ÉO MELHORADA =====
      document.addEventListener('DOMContentLoaded', function() {
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');
        const exportBtn = document.getElementById('exportBtn');
        const saveBtn = document.getElementById('saveBtn');
        const clearBtn = document.getElementById('clearBtn');
        
        checkLibraries();
        
        // Verifica√ß√£o melhorada de arquivos das bibliotecas
        const libraryChecks = [
          { path: './libs/pdf.min.mjs', name: 'pdf.min.mjs' },
          { path: './libs/tesseract.esm.min.js', name: 'tesseract.esm.min.js' },
          { path: './libs/xlsx.mjs', name: 'xlsx.mjs' }
        ];
        
        libraryChecks.forEach(lib => {
          fetch(lib.path)
            .then(response => {
              if (response.ok) {
                console.log(`‚úÖ ${lib.name} encontrado`);
              } else {
                console.error(`‚ùå ${lib.name} n√£o encontrado - c√≥digo:`, response.status);
              }
            })
            .catch(error => {
              console.error(`‚ùå Erro ao acessar ${lib.name}:`, error);
              showNotification(`‚ùå Biblioteca ${lib.name} n√£o encontrada na pasta ./libs/`, 'error');
            });
        });
        
        fileInput.addEventListener('change', function(e) {
          console.log('üìÅ Arquivos selecionados:', e.target.files.length);
          
          const files = Array.from(e.target.files).filter(file => {
            const isValid = file.type === 'application/pdf' || file.type.startsWith('image/');
            console.log(`üìÑ ${file.name}: ${file.type} - ${isValid ? 'V√ÅLIDO' : 'INV√ÅLIDO'}`);
            return isValid;
          });
          
          if (files.length > 0) {
            console.log('üöÄ Iniciando processamento melhorado de', files.length, 'arquivo(s) v√°lido(s)');
            handleFiles(files);
          } else {
            showNotification('‚ùå Nenhum arquivo PDF ou imagem v√°lido selecionado', 'error');
          }
          
          e.target.value = '';
        });
        
        uploadSection.addEventListener('dragover', function(e) {
          e.preventDefault();
          uploadSection.classList.add('dragover');
        });
        
        uploadSection.addEventListener('dragleave', function(e) {
          e.preventDefault();
          uploadSection.classList.remove('dragover');
        });
        
        uploadSection.addEventListener('drop', function(e) {
          e.preventDefault();
          uploadSection.classList.remove('dragover');
          
          console.log('üìÅ Arquivos soltos:', e.dataTransfer.files.length);
          
          const files = Array.from(e.dataTransfer.files).filter(file => {
            const isValid = file.type === 'application/pdf' || file.type.startsWith('image/');
            console.log(`üìÑ ${file.name}: ${file.type} - ${isValid ? 'V√ÅLIDO' : 'INV√ÅLIDO'}`);
            return isValid;
          });
          
          if (files.length > 0) {
            console.log('üöÄ Iniciando processamento melhorado de', files.length, 'arquivo(s) v√°lido(s)');
            handleFiles(files);
          } else {
            showNotification('‚ùå Nenhum arquivo PDF ou imagem v√°lido encontrado', 'error');
          }
        });
        
        exportBtn.addEventListener('click', exportToExcel);
        saveBtn.addEventListener('click', saveDataToLocalStorage);
        clearBtn.addEventListener('click', clearAllData);
        
        console.log('üéØ Sistema v4.0 Melhorado - Totalmente Implementado!');
        console.log('üîß MELHORIAS v4.0:');
        console.log('   ‚úÖ Extra√ß√£o espec√≠fica de todos os campos solicitados');
        console.log('   ‚úÖ ocr_prestador_complemento implementado');
        console.log('   ‚úÖ ocr_prestador_cpf_cnpj implementado');
        console.log('   ‚úÖ ocr_numero_nota melhorado');
        console.log('   ‚úÖ ocr_data_hora_emissao melhorado');
        console.log('   ‚úÖ ocr_valor_servico melhorado');
        console.log('   ‚úÖ ocr_descricao_servico melhorado');
        console.log('   ‚úÖ ocr_placa_veiculo implementado');
        console.log('   ‚úÖ NOVO: Sistema de aprendizado de nomes de empresas por CNPJ/CPF');
        console.log('üì± OCR MELHORADO v4.0:');
        console.log('   ‚úÖ Pr√©-processamento de imagem para melhor qualidade');
        console.log('   ‚úÖ Configura√ß√µes otimizadas Tesseract');
        console.log('   ‚úÖ Suporte completo a acentos portugueses');
        console.log('   ‚úÖ Melhor extra√ß√£o de texto em PDFs');
        console.log('   ‚úÖ Ordena√ß√£o inteligente de texto por posi√ß√£o');
        console.log('üìã CAMPOS EXTRA√çDOS v4.0:');
        console.log('   ‚úÖ CPF/CNPJ do Prestador (valida√ß√£o inclu√≠da)');
        console.log('   ‚úÖ Nome do Prestador (sistema de aprendizado)');
        console.log('   ‚úÖ Complemento do Prestador (endere√ßo)');
        console.log('   ‚úÖ N√∫mero da Nota (m√∫ltiplas estrat√©gias)');
        console.log('   ‚úÖ Data/Hora de Emiss√£o (formatos variados)');
        console.log('   ‚úÖ Valor do Servi√ßo (valida√ß√£o monet√°ria)');
        console.log('   ‚úÖ Descri√ß√£o do Servi√ßo (an√°lise contextual)');
        console.log('   ‚úÖ Placa do Ve√≠culo (formatos antigo e Mercosul)');
        console.log('üÜï VALIDA√á√ïES v4.0:');
        console.log('   ‚úÖ Valida√ß√£o de CPF com d√≠gitos verificadores');
        console.log('   ‚úÖ Valida√ß√£o de CNPJ com d√≠gitos verificadores');
        console.log('   ‚úÖ Valida√ß√£o de placas (antigo e Mercosul)');
        console.log('   ‚úÖ Valida√ß√£o de valores monet√°rios');
        console.log('   ‚úÖ Valida√ß√£o de datas (formato e per√≠odo)');
        console.log('   ‚úÖ Valida√ß√£o de nomes de empresas');
        console.log('üöÄ SISTEMA COMPLETO:');
        console.log('   ‚úÖ Interface adaptada para novos campos');
        console.log('   ‚úÖ Exporta√ß√£o Excel melhorada');
        console.log('   ‚úÖ Sistema de filtros atualizado');
        console.log('   ‚úÖ Debug detalhado para cada campo');
        console.log('   ‚úÖ Estat√≠sticas atualizadas');
        console.log('   ‚úÖ Backup/Restaura√ß√£o de dados e empresas aprendidas');
        
        console.log('');
        console.log('üéØ SISTEMA v4.0 MELHORADO PRONTO PARA USO! üéØ');
        console.log('‚úÖ Todas as funcionalidades solicitadas implementadas');
        console.log('‚úÖ OCR otimizado para documentos brasileiros');
        console.log('‚úÖ Extra√ß√£o completa de todos os campos');
        console.log('‚úÖ Valida√ß√µes robustas implementadas');
        console.log('‚úÖ Aprendizado de nomes de empresas implementado');
        console.log('');
      });
    </script>
  </body>
</html>


